"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/indexeddb-manager.ts":
/*!**********************************!*\
  !*** ./lib/indexeddb-manager.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dbManager: function() { return /* binding */ dbManager; }\n/* harmony export */ });\n// IndexedDB Manager for large transaction datasets\n// Handles streaming writes and cursor-based reads to avoid loading all data into memory\nconst DB_NAME = \"sr-analytics-transactions\";\nconst STORE_NAME = \"transactions\";\nconst DB_VERSION = 2; // Increment when schema changes\nclass IndexedDBTransactionManager {\n    async init() {\n        if (this.db) return;\n        if (this.initPromise) return this.initPromise;\n        // Check if IndexedDB is available\n        if ( false || !window.indexedDB) {\n            const error = new Error(\"IndexedDB is not available in this browser. Please use a modern browser that supports IndexedDB.\");\n            this.initPromise = null;\n            throw error;\n        }\n        this.initPromise = new Promise((resolve, reject)=>{\n            let request;\n            try {\n                request = indexedDB.open(DB_NAME, DB_VERSION);\n            } catch (error) {\n                this.initPromise = null;\n                reject(new Error(\"Failed to open IndexedDB: \".concat((error === null || error === void 0 ? void 0 : error.message) || \"Unknown error\")));\n                return;\n            }\n            request.onerror = (event)=>{\n                var _event_target;\n                this.initPromise = null;\n                const error = (_event_target = event.target) === null || _event_target === void 0 ? void 0 : _event_target.error;\n                const errorMessage = (error === null || error === void 0 ? void 0 : error.message) || \"Unknown error\";\n                const errorName = (error === null || error === void 0 ? void 0 : error.name) || \"UnknownError\";\n                // Provide more specific error messages\n                let userMessage = \"Failed to open IndexedDB\";\n                if (errorName === \"QuotaExceededError\") {\n                    userMessage = \"IndexedDB quota exceeded. Please clear some browser storage or use a smaller file.\";\n                } else if (errorName === \"VersionError\") {\n                    userMessage = \"IndexedDB version conflict. Please refresh the page or clear browser storage.\";\n                } else if (errorName === \"InvalidStateError\") {\n                    userMessage = \"IndexedDB is in an invalid state. Please refresh the page.\";\n                } else if (errorName === \"AbortError\") {\n                    userMessage = \"IndexedDB operation was aborted. Please try again.\";\n                } else {\n                    userMessage = \"Failed to open IndexedDB: \".concat(errorMessage);\n                }\n                console.error(\"IndexedDB open error:\", errorName, errorMessage, error);\n                reject(new Error(userMessage));\n            };\n            request.onblocked = ()=>{\n                console.warn(\"IndexedDB upgrade blocked. Please close other tabs using this database.\");\n            // Don't reject here - the upgrade might complete later\n            };\n            request.onsuccess = ()=>{\n                this.db = request.result;\n                // Handle database close events\n                this.db.onerror = (event)=>{\n                    console.error(\"IndexedDB error:\", event);\n                };\n                this.db.onclose = ()=>{\n                    console.warn(\"IndexedDB connection closed\");\n                    this.db = null;\n                    this.initPromise = null;\n                };\n                this.db.onversionchange = ()=>{\n                    var _this_db;\n                    console.warn(\"IndexedDB version change detected. Please refresh the page.\");\n                    (_this_db = this.db) === null || _this_db === void 0 ? void 0 : _this_db.close();\n                    this.db = null;\n                    this.initPromise = null;\n                };\n                resolve();\n            };\n            request.onupgradeneeded = (event)=>{\n                const database = event.target.result;\n                try {\n                    // Delete old object store if it exists\n                    if (database.objectStoreNames.contains(STORE_NAME)) {\n                        database.deleteObjectStore(STORE_NAME);\n                    }\n                    // Create object store with indexes for efficient querying\n                    const objectStore = database.createObjectStore(STORE_NAME, {\n                        keyPath: \"_pk\",\n                        autoIncrement: true\n                    });\n                    // Create indexes for filtering\n                    objectStore.createIndex(\"txtime\", \"txtime\", {\n                        unique: false\n                    });\n                    objectStore.createIndex(\"paymentmode\", \"paymentmode\", {\n                        unique: false\n                    });\n                    objectStore.createIndex(\"merchantid\", \"merchantid\", {\n                        unique: false\n                    });\n                    objectStore.createIndex(\"pg\", \"pg\", {\n                        unique: false\n                    });\n                    objectStore.createIndex(\"bankname\", \"bankname\", {\n                        unique: false\n                    });\n                    objectStore.createIndex(\"cardtype\", \"cardtype\", {\n                        unique: false\n                    });\n                    objectStore.createIndex(\"transactionDate\", \"transactionDate\", {\n                        unique: false\n                    });\n                } catch (upgradeError) {\n                    console.error(\"IndexedDB upgrade error:\", upgradeError);\n                    reject(new Error(\"Failed to upgrade IndexedDB: \".concat((upgradeError === null || upgradeError === void 0 ? void 0 : upgradeError.message) || \"Unknown error\")));\n                }\n            };\n        });\n        return this.initPromise;\n    }\n    async clear() {\n        await this.init();\n        if (!this.db) throw new Error(\"Database not initialized\");\n        return new Promise((resolve, reject)=>{\n            const transaction = this.db.transaction([\n                STORE_NAME\n            ], \"readwrite\");\n            const store = transaction.objectStore(STORE_NAME);\n            const request = store.clear();\n            request.onerror = ()=>reject(request.error);\n            request.onsuccess = ()=>resolve();\n        });\n    }\n    async getCount() {\n        await this.init();\n        if (!this.db) throw new Error(\"Database not initialized\");\n        return new Promise((resolve, reject)=>{\n            const transaction = this.db.transaction([\n                STORE_NAME\n            ], \"readonly\");\n            const store = transaction.objectStore(STORE_NAME);\n            const request = store.count();\n            request.onerror = ()=>reject(request.error);\n            request.onsuccess = ()=>resolve(request.result);\n        });\n    }\n    async addTransactions(transactions) {\n        await this.init();\n        if (!this.db) throw new Error(\"Database not initialized\");\n        // Process in chunks to avoid blocking\n        const chunkSize = 10000;\n        for(let i = 0; i < transactions.length; i += chunkSize){\n            const chunk = transactions.slice(i, i + chunkSize);\n            await new Promise((resolve, reject)=>{\n                const transaction = this.db.transaction([\n                    STORE_NAME\n                ], \"readwrite\");\n                const store = transaction.objectStore(STORE_NAME);\n                transaction.onerror = ()=>reject(transaction.error);\n                transaction.oncomplete = ()=>resolve();\n                chunk.forEach((tx)=>{\n                    store.add(tx);\n                });\n            });\n            // Yield to browser after each chunk\n            if (i + chunkSize < transactions.length) {\n                await new Promise((resolve)=>setTimeout(resolve, 0));\n            }\n        }\n    }\n    async streamTransactions(onChunk) {\n        let chunkSize = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 50000, filters = arguments.length > 2 ? arguments[2] : void 0;\n        await this.init();\n        if (!this.db) throw new Error(\"Database not initialized\");\n        return new Promise((resolve, reject)=>{\n            const transaction = this.db.transaction([\n                STORE_NAME\n            ], \"readonly\");\n            const store = transaction.objectStore(STORE_NAME);\n            const request = store.openCursor();\n            let chunk = [];\n            let processed = 0;\n            request.onerror = ()=>reject(request.error);\n            request.onsuccess = async (event)=>{\n                const cursor = event.target.result;\n                if (!cursor) {\n                    // Process last chunk\n                    if (chunk.length > 0) {\n                        try {\n                            await onChunk(chunk);\n                        } catch (error) {\n                            reject(error);\n                            return;\n                        }\n                    }\n                    resolve();\n                    return;\n                }\n                const tx = cursor.value;\n                // Apply filters\n                let include = true;\n                if (filters) {\n                    if (filters.startDate && tx.txtime < filters.startDate) include = false;\n                    if (filters.endDate && tx.txtime > filters.endDate) include = false;\n                    if (filters.paymentModes && filters.paymentModes.length > 0) {\n                        if (!filters.paymentModes.includes(tx.paymentmode)) include = false;\n                    }\n                    if (filters.merchantIds && filters.merchantIds.length > 0) {\n                        const merchantId = String(tx.merchantid || \"\").trim();\n                        if (!filters.merchantIds.includes(merchantId)) include = false;\n                    }\n                    if (filters.pgs && filters.pgs.length > 0) {\n                        if (!filters.pgs.includes(tx.pg)) include = false;\n                    }\n                    if (filters.banks && filters.banks.length > 0) {\n                        const flow = tx.bankname || \"\";\n                        if (!filters.banks.includes(flow) && !filters.banks.includes(tx.bankname || \"\")) include = false;\n                    }\n                    if (filters.cardTypes && filters.cardTypes.length > 0) {\n                        if (!filters.cardTypes.includes(tx.cardtype)) include = false;\n                    }\n                }\n                if (include) {\n                    chunk.push(tx);\n                }\n                processed++;\n                // Yield periodically for very large datasets\n                if (processed % 10000 === 0) {\n                    cursor.continue();\n                    await new Promise((resolve)=>setTimeout(resolve, 0));\n                    return;\n                }\n                // Process chunk when it reaches chunkSize\n                if (chunk.length >= chunkSize) {\n                    const chunkToProcess = [\n                        ...chunk\n                    ];\n                    chunk = [];\n                    try {\n                        await onChunk(chunkToProcess);\n                        // Yield after processing chunk\n                        await new Promise((resolve)=>setTimeout(resolve, 0));\n                    } catch (error) {\n                        reject(error);\n                        return;\n                    }\n                }\n                cursor.continue();\n            };\n        });\n    }\n    async getAllTransactions(filters) {\n        const results = [];\n        await this.streamTransactions(async (chunk)=>{\n            results.push(...chunk);\n        }, 50000, filters);\n        return results;\n    }\n    async sampleTransactions(maxRows, filters) {\n        const results = [];\n        await this.streamTransactions(async (chunk)=>{\n            if (results.length < maxRows) {\n                const remaining = maxRows - results.length;\n                results.push(...chunk.slice(0, remaining));\n            }\n        }, 50000, filters);\n        return results;\n    }\n    async getFilteredTimeBounds(filters) {\n        await this.init();\n        if (!this.db) throw new Error(\"Database not initialized\");\n        let minDate = null;\n        let maxDate = null;\n        await this.streamTransactions(async (chunk)=>{\n            for (const tx of chunk){\n                const txTime = tx.txtime instanceof Date ? tx.txtime : new Date(tx.txtime);\n                if (!minDate || txTime < minDate) minDate = txTime;\n                if (!maxDate || txTime > maxDate) maxDate = txTime;\n            }\n        }, 50000, filters);\n        return {\n            min: minDate || undefined,\n            max: maxDate || undefined\n        };\n    }\n    async aggregateMetrics(filters) {\n        await this.init();\n        if (!this.db) throw new Error(\"Database not initialized\");\n        let totalCount = 0;\n        let successCount = 0;\n        let failedCount = 0;\n        let userDroppedCount = 0;\n        let successGmv = 0;\n        const dailyMap = new Map();\n        await this.streamTransactions(async (chunk)=>{\n            for (const tx of chunk){\n                totalCount++;\n                if (tx.isSuccess) {\n                    successCount++;\n                    successGmv += tx.txamount || 0;\n                } else if (tx.isFailed) {\n                    failedCount++;\n                } else if (tx.isUserDropped) {\n                    userDroppedCount++;\n                }\n                const date = tx.transactionDate;\n                if (!dailyMap.has(date)) {\n                    dailyMap.set(date, {\n                        date,\n                        volume: 0,\n                        successCount: 0,\n                        failedCount: 0,\n                        userDroppedCount: 0\n                    });\n                }\n                const trend = dailyMap.get(date);\n                trend.volume++;\n                if (tx.isSuccess) trend.successCount++;\n                if (tx.isFailed) trend.failedCount++;\n                if (tx.isUserDropped) trend.userDroppedCount++;\n            }\n        }, 50000, filters);\n        const dailyTrends = Array.from(dailyMap.values()).sort((a, b)=>a.date.localeCompare(b.date));\n        return {\n            totalCount,\n            successCount,\n            failedCount,\n            userDroppedCount,\n            successGmv,\n            dailyTrends\n        };\n    }\n    constructor(){\n        this.db = null;\n        this.initPromise = null;\n    }\n}\nconst dbManager = new IndexedDBTransactionManager();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9pbmRleGVkZGItbWFuYWdlci50cyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsbURBQW1EO0FBQ25ELHdGQUF3RjtBQUl4RixNQUFNQSxVQUFVO0FBQ2hCLE1BQU1DLGFBQWE7QUFDbkIsTUFBTUMsYUFBYSxHQUFHLGdDQUFnQztBQXVCdEQsTUFBTUM7SUFJSixNQUFNQyxPQUFzQjtRQUMxQixJQUFJLElBQUksQ0FBQ0MsRUFBRSxFQUFFO1FBQ2IsSUFBSSxJQUFJLENBQUNDLFdBQVcsRUFBRSxPQUFPLElBQUksQ0FBQ0EsV0FBVztRQUU3QyxrQ0FBa0M7UUFDbEMsSUFBSSxNQUFrQixJQUFlLENBQUNDLE9BQU9DLFNBQVMsRUFBRTtZQUN0RCxNQUFNQyxRQUFRLElBQUlDLE1BQU07WUFDeEIsSUFBSSxDQUFDSixXQUFXLEdBQUc7WUFDbkIsTUFBTUc7UUFDUjtRQUVBLElBQUksQ0FBQ0gsV0FBVyxHQUFHLElBQUlLLFFBQVEsQ0FBQ0MsU0FBU0M7WUFDdkMsSUFBSUM7WUFFSixJQUFJO2dCQUNGQSxVQUFVTixVQUFVTyxJQUFJLENBQUNmLFNBQVNFO1lBQ3BDLEVBQUUsT0FBT08sT0FBWTtnQkFDbkIsSUFBSSxDQUFDSCxXQUFXLEdBQUc7Z0JBQ25CTyxPQUFPLElBQUlILE1BQU0sNkJBQStELE9BQWxDRCxDQUFBQSxrQkFBQUEsNEJBQUFBLE1BQU9PLE9BQU8sS0FBSTtnQkFDaEU7WUFDRjtZQUVBRixRQUFRRyxPQUFPLEdBQUcsQ0FBQ0M7b0JBRUZBO2dCQURmLElBQUksQ0FBQ1osV0FBVyxHQUFHO2dCQUNuQixNQUFNRyxTQUFTUyxnQkFBQUEsTUFBTUMsTUFBTSxjQUFaRCxvQ0FBRCxjQUE4QlQsS0FBSztnQkFDakQsTUFBTVcsZUFBZVgsQ0FBQUEsa0JBQUFBLDRCQUFBQSxNQUFPTyxPQUFPLEtBQUk7Z0JBQ3ZDLE1BQU1LLFlBQVlaLENBQUFBLGtCQUFBQSw0QkFBQUEsTUFBT2EsSUFBSSxLQUFJO2dCQUVqQyx1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QUFZLElBQUkvSCw4QkFBOEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL2luZGV4ZWRkYi1tYW5hZ2VyLnRzPzE3YmUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW5kZXhlZERCIE1hbmFnZXIgZm9yIGxhcmdlIHRyYW5zYWN0aW9uIGRhdGFzZXRzXG4vLyBIYW5kbGVzIHN0cmVhbWluZyB3cml0ZXMgYW5kIGN1cnNvci1iYXNlZCByZWFkcyB0byBhdm9pZCBsb2FkaW5nIGFsbCBkYXRhIGludG8gbWVtb3J5XG5cbmltcG9ydCB7IFRyYW5zYWN0aW9uIH0gZnJvbSAnQC90eXBlcyc7XG5cbmNvbnN0IERCX05BTUUgPSAnc3ItYW5hbHl0aWNzLXRyYW5zYWN0aW9ucyc7XG5jb25zdCBTVE9SRV9OQU1FID0gJ3RyYW5zYWN0aW9ucyc7XG5jb25zdCBEQl9WRVJTSU9OID0gMjsgLy8gSW5jcmVtZW50IHdoZW4gc2NoZW1hIGNoYW5nZXNcblxuaW50ZXJmYWNlIERCTWFuYWdlciB7XG4gIGluaXQoKTogUHJvbWlzZTx2b2lkPjtcbiAgY2xlYXIoKTogUHJvbWlzZTx2b2lkPjtcbiAgZ2V0Q291bnQoKTogUHJvbWlzZTxudW1iZXI+O1xuICBhZGRUcmFuc2FjdGlvbnModHJhbnNhY3Rpb25zOiBUcmFuc2FjdGlvbltdKTogUHJvbWlzZTx2b2lkPjtcbiAgc3RyZWFtVHJhbnNhY3Rpb25zKFxuICAgIG9uQ2h1bms6IChjaHVuazogVHJhbnNhY3Rpb25bXSkgPT4gUHJvbWlzZTx2b2lkPixcbiAgICBjaHVua1NpemU/OiBudW1iZXIsXG4gICAgZmlsdGVycz86IHtcbiAgICAgIHN0YXJ0RGF0ZT86IERhdGU7XG4gICAgICBlbmREYXRlPzogRGF0ZTtcbiAgICAgIHBheW1lbnRNb2Rlcz86IHN0cmluZ1tdO1xuICAgICAgbWVyY2hhbnRJZHM/OiBzdHJpbmdbXTtcbiAgICAgIHBncz86IHN0cmluZ1tdO1xuICAgICAgYmFua3M/OiBzdHJpbmdbXTtcbiAgICAgIGNhcmRUeXBlcz86IHN0cmluZ1tdO1xuICAgIH1cbiAgKTogUHJvbWlzZTx2b2lkPjtcbiAgZ2V0QWxsVHJhbnNhY3Rpb25zKGZpbHRlcnM/OiBhbnkpOiBQcm9taXNlPFRyYW5zYWN0aW9uW10+O1xufVxuXG5jbGFzcyBJbmRleGVkREJUcmFuc2FjdGlvbk1hbmFnZXIgaW1wbGVtZW50cyBEQk1hbmFnZXIge1xuICBwcml2YXRlIGRiOiBJREJEYXRhYmFzZSB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGluaXRQcm9taXNlOiBQcm9taXNlPHZvaWQ+IHwgbnVsbCA9IG51bGw7XG5cbiAgYXN5bmMgaW5pdCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAodGhpcy5kYikgcmV0dXJuO1xuICAgIGlmICh0aGlzLmluaXRQcm9taXNlKSByZXR1cm4gdGhpcy5pbml0UHJvbWlzZTtcblxuICAgIC8vIENoZWNrIGlmIEluZGV4ZWREQiBpcyBhdmFpbGFibGVcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgIXdpbmRvdy5pbmRleGVkREIpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdJbmRleGVkREIgaXMgbm90IGF2YWlsYWJsZSBpbiB0aGlzIGJyb3dzZXIuIFBsZWFzZSB1c2UgYSBtb2Rlcm4gYnJvd3NlciB0aGF0IHN1cHBvcnRzIEluZGV4ZWREQi4nKTtcbiAgICAgIHRoaXMuaW5pdFByb21pc2UgPSBudWxsO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgdGhpcy5pbml0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxldCByZXF1ZXN0OiBJREJPcGVuREJSZXF1ZXN0O1xuICAgICAgXG4gICAgICB0cnkge1xuICAgICAgICByZXF1ZXN0ID0gaW5kZXhlZERCLm9wZW4oREJfTkFNRSwgREJfVkVSU0lPTik7XG4gICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgIHRoaXMuaW5pdFByb21pc2UgPSBudWxsO1xuICAgICAgICByZWplY3QobmV3IEVycm9yKGBGYWlsZWQgdG8gb3BlbiBJbmRleGVkREI6ICR7ZXJyb3I/Lm1lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3InfWApKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgdGhpcy5pbml0UHJvbWlzZSA9IG51bGw7XG4gICAgICAgIGNvbnN0IGVycm9yID0gKGV2ZW50LnRhcmdldCBhcyBJREJSZXF1ZXN0KT8uZXJyb3I7XG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yPy5tZXNzYWdlIHx8ICdVbmtub3duIGVycm9yJztcbiAgICAgICAgY29uc3QgZXJyb3JOYW1lID0gZXJyb3I/Lm5hbWUgfHwgJ1Vua25vd25FcnJvcic7XG4gICAgICAgIFxuICAgICAgICAvLyBQcm92aWRlIG1vcmUgc3BlY2lmaWMgZXJyb3IgbWVzc2FnZXNcbiAgICAgICAgbGV0IHVzZXJNZXNzYWdlID0gJ0ZhaWxlZCB0byBvcGVuIEluZGV4ZWREQic7XG4gICAgICAgIGlmIChlcnJvck5hbWUgPT09ICdRdW90YUV4Y2VlZGVkRXJyb3InKSB7XG4gICAgICAgICAgdXNlck1lc3NhZ2UgPSAnSW5kZXhlZERCIHF1b3RhIGV4Y2VlZGVkLiBQbGVhc2UgY2xlYXIgc29tZSBicm93c2VyIHN0b3JhZ2Ugb3IgdXNlIGEgc21hbGxlciBmaWxlLic7XG4gICAgICAgIH0gZWxzZSBpZiAoZXJyb3JOYW1lID09PSAnVmVyc2lvbkVycm9yJykge1xuICAgICAgICAgIHVzZXJNZXNzYWdlID0gJ0luZGV4ZWREQiB2ZXJzaW9uIGNvbmZsaWN0LiBQbGVhc2UgcmVmcmVzaCB0aGUgcGFnZSBvciBjbGVhciBicm93c2VyIHN0b3JhZ2UuJztcbiAgICAgICAgfSBlbHNlIGlmIChlcnJvck5hbWUgPT09ICdJbnZhbGlkU3RhdGVFcnJvcicpIHtcbiAgICAgICAgICB1c2VyTWVzc2FnZSA9ICdJbmRleGVkREIgaXMgaW4gYW4gaW52YWxpZCBzdGF0ZS4gUGxlYXNlIHJlZnJlc2ggdGhlIHBhZ2UuJztcbiAgICAgICAgfSBlbHNlIGlmIChlcnJvck5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICAgIHVzZXJNZXNzYWdlID0gJ0luZGV4ZWREQiBvcGVyYXRpb24gd2FzIGFib3J0ZWQuIFBsZWFzZSB0cnkgYWdhaW4uJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1c2VyTWVzc2FnZSA9IGBGYWlsZWQgdG8gb3BlbiBJbmRleGVkREI6ICR7ZXJyb3JNZXNzYWdlfWA7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0luZGV4ZWREQiBvcGVuIGVycm9yOicsIGVycm9yTmFtZSwgZXJyb3JNZXNzYWdlLCBlcnJvcik7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IodXNlck1lc3NhZ2UpKTtcbiAgICAgIH07XG5cbiAgICAgIHJlcXVlc3Qub25ibG9ja2VkID0gKCkgPT4ge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0luZGV4ZWREQiB1cGdyYWRlIGJsb2NrZWQuIFBsZWFzZSBjbG9zZSBvdGhlciB0YWJzIHVzaW5nIHRoaXMgZGF0YWJhc2UuJyk7XG4gICAgICAgIC8vIERvbid0IHJlamVjdCBoZXJlIC0gdGhlIHVwZ3JhZGUgbWlnaHQgY29tcGxldGUgbGF0ZXJcbiAgICAgIH07XG5cbiAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICB0aGlzLmRiID0gcmVxdWVzdC5yZXN1bHQ7XG4gICAgICAgIFxuICAgICAgICAvLyBIYW5kbGUgZGF0YWJhc2UgY2xvc2UgZXZlbnRzXG4gICAgICAgIHRoaXMuZGIub25lcnJvciA9IChldmVudCkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0luZGV4ZWREQiBlcnJvcjonLCBldmVudCk7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICB0aGlzLmRiLm9uY2xvc2UgPSAoKSA9PiB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdJbmRleGVkREIgY29ubmVjdGlvbiBjbG9zZWQnKTtcbiAgICAgICAgICB0aGlzLmRiID0gbnVsbDtcbiAgICAgICAgICB0aGlzLmluaXRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuZGIub252ZXJzaW9uY2hhbmdlID0gKCkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUud2FybignSW5kZXhlZERCIHZlcnNpb24gY2hhbmdlIGRldGVjdGVkLiBQbGVhc2UgcmVmcmVzaCB0aGUgcGFnZS4nKTtcbiAgICAgICAgICB0aGlzLmRiPy5jbG9zZSgpO1xuICAgICAgICAgIHRoaXMuZGIgPSBudWxsO1xuICAgICAgICAgIHRoaXMuaW5pdFByb21pc2UgPSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfTtcblxuICAgICAgcmVxdWVzdC5vbnVwZ3JhZGVuZWVkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgZGF0YWJhc2UgPSAoZXZlbnQudGFyZ2V0IGFzIElEQk9wZW5EQlJlcXVlc3QpLnJlc3VsdDtcbiAgICAgICAgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gRGVsZXRlIG9sZCBvYmplY3Qgc3RvcmUgaWYgaXQgZXhpc3RzXG4gICAgICAgICAgaWYgKGRhdGFiYXNlLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnMoU1RPUkVfTkFNRSkpIHtcbiAgICAgICAgICAgIGRhdGFiYXNlLmRlbGV0ZU9iamVjdFN0b3JlKFNUT1JFX05BTUUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENyZWF0ZSBvYmplY3Qgc3RvcmUgd2l0aCBpbmRleGVzIGZvciBlZmZpY2llbnQgcXVlcnlpbmdcbiAgICAgICAgICBjb25zdCBvYmplY3RTdG9yZSA9IGRhdGFiYXNlLmNyZWF0ZU9iamVjdFN0b3JlKFNUT1JFX05BTUUsIHtcbiAgICAgICAgICAgIGtleVBhdGg6ICdfcGsnLFxuICAgICAgICAgICAgYXV0b0luY3JlbWVudDogdHJ1ZSxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIENyZWF0ZSBpbmRleGVzIGZvciBmaWx0ZXJpbmdcbiAgICAgICAgICBvYmplY3RTdG9yZS5jcmVhdGVJbmRleCgndHh0aW1lJywgJ3R4dGltZScsIHsgdW5pcXVlOiBmYWxzZSB9KTtcbiAgICAgICAgICBvYmplY3RTdG9yZS5jcmVhdGVJbmRleCgncGF5bWVudG1vZGUnLCAncGF5bWVudG1vZGUnLCB7IHVuaXF1ZTogZmFsc2UgfSk7XG4gICAgICAgICAgb2JqZWN0U3RvcmUuY3JlYXRlSW5kZXgoJ21lcmNoYW50aWQnLCAnbWVyY2hhbnRpZCcsIHsgdW5pcXVlOiBmYWxzZSB9KTtcbiAgICAgICAgICBvYmplY3RTdG9yZS5jcmVhdGVJbmRleCgncGcnLCAncGcnLCB7IHVuaXF1ZTogZmFsc2UgfSk7XG4gICAgICAgICAgb2JqZWN0U3RvcmUuY3JlYXRlSW5kZXgoJ2JhbmtuYW1lJywgJ2JhbmtuYW1lJywgeyB1bmlxdWU6IGZhbHNlIH0pO1xuICAgICAgICAgIG9iamVjdFN0b3JlLmNyZWF0ZUluZGV4KCdjYXJkdHlwZScsICdjYXJkdHlwZScsIHsgdW5pcXVlOiBmYWxzZSB9KTtcbiAgICAgICAgICBvYmplY3RTdG9yZS5jcmVhdGVJbmRleCgndHJhbnNhY3Rpb25EYXRlJywgJ3RyYW5zYWN0aW9uRGF0ZScsIHsgdW5pcXVlOiBmYWxzZSB9KTtcbiAgICAgICAgfSBjYXRjaCAodXBncmFkZUVycm9yOiBhbnkpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdJbmRleGVkREIgdXBncmFkZSBlcnJvcjonLCB1cGdyYWRlRXJyb3IpO1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYEZhaWxlZCB0byB1cGdyYWRlIEluZGV4ZWREQjogJHt1cGdyYWRlRXJyb3I/Lm1lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3InfWApKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzLmluaXRQcm9taXNlO1xuICB9XG5cbiAgYXN5bmMgY2xlYXIoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgYXdhaXQgdGhpcy5pbml0KCk7XG4gICAgaWYgKCF0aGlzLmRiKSB0aHJvdyBuZXcgRXJyb3IoJ0RhdGFiYXNlIG5vdCBpbml0aWFsaXplZCcpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy5kYiEudHJhbnNhY3Rpb24oW1NUT1JFX05BTUVdLCAncmVhZHdyaXRlJyk7XG4gICAgICBjb25zdCBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKFNUT1JFX05BTUUpO1xuICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLmNsZWFyKCk7XG5cbiAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHJlamVjdChyZXF1ZXN0LmVycm9yKTtcbiAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4gcmVzb2x2ZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgZ2V0Q291bnQoKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICBhd2FpdCB0aGlzLmluaXQoKTtcbiAgICBpZiAoIXRoaXMuZGIpIHRocm93IG5ldyBFcnJvcignRGF0YWJhc2Ugbm90IGluaXRpYWxpemVkJyk7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSB0aGlzLmRiIS50cmFuc2FjdGlvbihbU1RPUkVfTkFNRV0sICdyZWFkb25seScpO1xuICAgICAgY29uc3Qgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShTVE9SRV9OQU1FKTtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5jb3VudCgpO1xuXG4gICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiByZWplY3QocmVxdWVzdC5lcnJvcik7XG4gICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHJlc29sdmUocmVxdWVzdC5yZXN1bHQpO1xuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgYWRkVHJhbnNhY3Rpb25zKHRyYW5zYWN0aW9uczogVHJhbnNhY3Rpb25bXSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHRoaXMuaW5pdCgpO1xuICAgIGlmICghdGhpcy5kYikgdGhyb3cgbmV3IEVycm9yKCdEYXRhYmFzZSBub3QgaW5pdGlhbGl6ZWQnKTtcblxuICAgIC8vIFByb2Nlc3MgaW4gY2h1bmtzIHRvIGF2b2lkIGJsb2NraW5nXG4gICAgY29uc3QgY2h1bmtTaXplID0gMTAwMDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFuc2FjdGlvbnMubGVuZ3RoOyBpICs9IGNodW5rU2l6ZSkge1xuICAgICAgY29uc3QgY2h1bmsgPSB0cmFuc2FjdGlvbnMuc2xpY2UoaSwgaSArIGNodW5rU2l6ZSk7XG4gICAgICBcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSB0aGlzLmRiIS50cmFuc2FjdGlvbihbU1RPUkVfTkFNRV0sICdyZWFkd3JpdGUnKTtcbiAgICAgICAgY29uc3Qgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShTVE9SRV9OQU1FKTtcblxuICAgICAgICB0cmFuc2FjdGlvbi5vbmVycm9yID0gKCkgPT4gcmVqZWN0KHRyYW5zYWN0aW9uLmVycm9yKTtcbiAgICAgICAgdHJhbnNhY3Rpb24ub25jb21wbGV0ZSA9ICgpID0+IHJlc29sdmUoKTtcblxuICAgICAgICBjaHVuay5mb3JFYWNoKCh0eCkgPT4ge1xuICAgICAgICAgIHN0b3JlLmFkZCh0eCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFlpZWxkIHRvIGJyb3dzZXIgYWZ0ZXIgZWFjaCBjaHVua1xuICAgICAgaWYgKGkgKyBjaHVua1NpemUgPCB0cmFuc2FjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAwKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgc3RyZWFtVHJhbnNhY3Rpb25zKFxuICAgIG9uQ2h1bms6IChjaHVuazogVHJhbnNhY3Rpb25bXSkgPT4gUHJvbWlzZTx2b2lkPixcbiAgICBjaHVua1NpemU6IG51bWJlciA9IDUwMDAwLFxuICAgIGZpbHRlcnM/OiB7XG4gICAgICBzdGFydERhdGU/OiBEYXRlO1xuICAgICAgZW5kRGF0ZT86IERhdGU7XG4gICAgICBwYXltZW50TW9kZXM/OiBzdHJpbmdbXTtcbiAgICAgIG1lcmNoYW50SWRzPzogc3RyaW5nW107XG4gICAgICBwZ3M/OiBzdHJpbmdbXTtcbiAgICAgIGJhbmtzPzogc3RyaW5nW107XG4gICAgICBjYXJkVHlwZXM/OiBzdHJpbmdbXTtcbiAgICB9XG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHRoaXMuaW5pdCgpO1xuICAgIGlmICghdGhpcy5kYikgdGhyb3cgbmV3IEVycm9yKCdEYXRhYmFzZSBub3QgaW5pdGlhbGl6ZWQnKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRoaXMuZGIhLnRyYW5zYWN0aW9uKFtTVE9SRV9OQU1FXSwgJ3JlYWRvbmx5Jyk7XG4gICAgICBjb25zdCBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKFNUT1JFX05BTUUpO1xuICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLm9wZW5DdXJzb3IoKTtcbiAgICAgIFxuICAgICAgbGV0IGNodW5rOiBUcmFuc2FjdGlvbltdID0gW107XG4gICAgICBsZXQgcHJvY2Vzc2VkID0gMDtcblxuICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4gcmVqZWN0KHJlcXVlc3QuZXJyb3IpO1xuXG4gICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9IGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCBjdXJzb3IgPSAoZXZlbnQudGFyZ2V0IGFzIElEQlJlcXVlc3Q8SURCQ3Vyc29yV2l0aFZhbHVlPikucmVzdWx0O1xuICAgICAgICBcbiAgICAgICAgaWYgKCFjdXJzb3IpIHtcbiAgICAgICAgICAvLyBQcm9jZXNzIGxhc3QgY2h1bmtcbiAgICAgICAgICBpZiAoY2h1bmsubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgYXdhaXQgb25DaHVuayhjaHVuayk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0eCA9IGN1cnNvci52YWx1ZSBhcyBUcmFuc2FjdGlvbjtcblxuICAgICAgICAvLyBBcHBseSBmaWx0ZXJzXG4gICAgICAgIGxldCBpbmNsdWRlID0gdHJ1ZTtcbiAgICAgICAgXG4gICAgICAgIGlmIChmaWx0ZXJzKSB7XG4gICAgICAgICAgaWYgKGZpbHRlcnMuc3RhcnREYXRlICYmIHR4LnR4dGltZSA8IGZpbHRlcnMuc3RhcnREYXRlKSBpbmNsdWRlID0gZmFsc2U7XG4gICAgICAgICAgaWYgKGZpbHRlcnMuZW5kRGF0ZSAmJiB0eC50eHRpbWUgPiBmaWx0ZXJzLmVuZERhdGUpIGluY2x1ZGUgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoZmlsdGVycy5wYXltZW50TW9kZXMgJiYgZmlsdGVycy5wYXltZW50TW9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKCFmaWx0ZXJzLnBheW1lbnRNb2Rlcy5pbmNsdWRlcyh0eC5wYXltZW50bW9kZSkpIGluY2x1ZGUgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGZpbHRlcnMubWVyY2hhbnRJZHMgJiYgZmlsdGVycy5tZXJjaGFudElkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBtZXJjaGFudElkID0gU3RyaW5nKHR4Lm1lcmNoYW50aWQgfHwgJycpLnRyaW0oKTtcbiAgICAgICAgICAgIGlmICghZmlsdGVycy5tZXJjaGFudElkcy5pbmNsdWRlcyhtZXJjaGFudElkKSkgaW5jbHVkZSA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZmlsdGVycy5wZ3MgJiYgZmlsdGVycy5wZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKCFmaWx0ZXJzLnBncy5pbmNsdWRlcyh0eC5wZykpIGluY2x1ZGUgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGZpbHRlcnMuYmFua3MgJiYgZmlsdGVycy5iYW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBmbG93ID0gdHguYmFua25hbWUgfHwgJyc7XG4gICAgICAgICAgICBpZiAoIWZpbHRlcnMuYmFua3MuaW5jbHVkZXMoZmxvdykgJiYgIWZpbHRlcnMuYmFua3MuaW5jbHVkZXModHguYmFua25hbWUgfHwgJycpKSBpbmNsdWRlID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmaWx0ZXJzLmNhcmRUeXBlcyAmJiBmaWx0ZXJzLmNhcmRUeXBlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAoIWZpbHRlcnMuY2FyZFR5cGVzLmluY2x1ZGVzKHR4LmNhcmR0eXBlKSkgaW5jbHVkZSA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmNsdWRlKSB7XG4gICAgICAgICAgY2h1bmsucHVzaCh0eCk7XG4gICAgICAgIH1cblxuICAgICAgICBwcm9jZXNzZWQrKztcblxuICAgICAgICAvLyBZaWVsZCBwZXJpb2RpY2FsbHkgZm9yIHZlcnkgbGFyZ2UgZGF0YXNldHNcbiAgICAgICAgaWYgKHByb2Nlc3NlZCAlIDEwMDAwID09PSAwKSB7XG4gICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKCk7XG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDApKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQcm9jZXNzIGNodW5rIHdoZW4gaXQgcmVhY2hlcyBjaHVua1NpemVcbiAgICAgICAgaWYgKGNodW5rLmxlbmd0aCA+PSBjaHVua1NpemUpIHtcbiAgICAgICAgICBjb25zdCBjaHVua1RvUHJvY2VzcyA9IFsuLi5jaHVua107XG4gICAgICAgICAgY2h1bmsgPSBbXTtcbiAgICAgICAgICBcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgb25DaHVuayhjaHVua1RvUHJvY2Vzcyk7XG4gICAgICAgICAgICAvLyBZaWVsZCBhZnRlciBwcm9jZXNzaW5nIGNodW5rXG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnNvci5jb250aW51ZSgpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGdldEFsbFRyYW5zYWN0aW9ucyhmaWx0ZXJzPzogYW55KTogUHJvbWlzZTxUcmFuc2FjdGlvbltdPiB7XG4gICAgY29uc3QgcmVzdWx0czogVHJhbnNhY3Rpb25bXSA9IFtdO1xuICAgIFxuICAgIGF3YWl0IHRoaXMuc3RyZWFtVHJhbnNhY3Rpb25zKFxuICAgICAgYXN5bmMgKGNodW5rKSA9PiB7XG4gICAgICAgIHJlc3VsdHMucHVzaCguLi5jaHVuayk7XG4gICAgICB9LFxuICAgICAgNTAwMDAsXG4gICAgICBmaWx0ZXJzXG4gICAgKTtcblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cbiAgYXN5bmMgc2FtcGxlVHJhbnNhY3Rpb25zKG1heFJvd3M6IG51bWJlciwgZmlsdGVycz86IHtcbiAgICBzdGFydERhdGU/OiBEYXRlO1xuICAgIGVuZERhdGU/OiBEYXRlO1xuICAgIHBheW1lbnRNb2Rlcz86IHN0cmluZ1tdO1xuICAgIG1lcmNoYW50SWRzPzogc3RyaW5nW107XG4gICAgcGdzPzogc3RyaW5nW107XG4gICAgYmFua3M/OiBzdHJpbmdbXTtcbiAgICBjYXJkVHlwZXM/OiBzdHJpbmdbXTtcbiAgfSk6IFByb21pc2U8VHJhbnNhY3Rpb25bXT4ge1xuICAgIGNvbnN0IHJlc3VsdHM6IFRyYW5zYWN0aW9uW10gPSBbXTtcbiAgICBcbiAgICBhd2FpdCB0aGlzLnN0cmVhbVRyYW5zYWN0aW9ucyhcbiAgICAgIGFzeW5jIChjaHVuaykgPT4ge1xuICAgICAgICBpZiAocmVzdWx0cy5sZW5ndGggPCBtYXhSb3dzKSB7XG4gICAgICAgICAgY29uc3QgcmVtYWluaW5nID0gbWF4Um93cyAtIHJlc3VsdHMubGVuZ3RoO1xuICAgICAgICAgIHJlc3VsdHMucHVzaCguLi5jaHVuay5zbGljZSgwLCByZW1haW5pbmcpKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIDUwMDAwLFxuICAgICAgZmlsdGVyc1xuICAgICk7XG5cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIGFzeW5jIGdldEZpbHRlcmVkVGltZUJvdW5kcyhmaWx0ZXJzPzoge1xuICAgIHN0YXJ0RGF0ZT86IERhdGU7XG4gICAgZW5kRGF0ZT86IERhdGU7XG4gICAgcGF5bWVudE1vZGVzPzogc3RyaW5nW107XG4gICAgbWVyY2hhbnRJZHM/OiBzdHJpbmdbXTtcbiAgICBwZ3M/OiBzdHJpbmdbXTtcbiAgICBiYW5rcz86IHN0cmluZ1tdO1xuICAgIGNhcmRUeXBlcz86IHN0cmluZ1tdO1xuICB9KTogUHJvbWlzZTx7IG1pbj86IERhdGU7IG1heD86IERhdGUgfT4ge1xuICAgIGF3YWl0IHRoaXMuaW5pdCgpO1xuICAgIGlmICghdGhpcy5kYikgdGhyb3cgbmV3IEVycm9yKCdEYXRhYmFzZSBub3QgaW5pdGlhbGl6ZWQnKTtcblxuICAgIGxldCBtaW5EYXRlOiBEYXRlIHwgbnVsbCA9IG51bGw7XG4gICAgbGV0IG1heERhdGU6IERhdGUgfCBudWxsID0gbnVsbDtcblxuICAgIGF3YWl0IHRoaXMuc3RyZWFtVHJhbnNhY3Rpb25zKFxuICAgICAgYXN5bmMgKGNodW5rKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgdHggb2YgY2h1bmspIHtcbiAgICAgICAgICBjb25zdCB0eFRpbWUgPSB0eC50eHRpbWUgaW5zdGFuY2VvZiBEYXRlID8gdHgudHh0aW1lIDogbmV3IERhdGUodHgudHh0aW1lKTtcbiAgICAgICAgICBpZiAoIW1pbkRhdGUgfHwgdHhUaW1lIDwgbWluRGF0ZSkgbWluRGF0ZSA9IHR4VGltZTtcbiAgICAgICAgICBpZiAoIW1heERhdGUgfHwgdHhUaW1lID4gbWF4RGF0ZSkgbWF4RGF0ZSA9IHR4VGltZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIDUwMDAwLFxuICAgICAgZmlsdGVyc1xuICAgICk7XG5cbiAgICByZXR1cm4geyBcbiAgICAgIG1pbjogbWluRGF0ZSB8fCB1bmRlZmluZWQsIFxuICAgICAgbWF4OiBtYXhEYXRlIHx8IHVuZGVmaW5lZCBcbiAgICB9O1xuICB9XG5cbiAgYXN5bmMgYWdncmVnYXRlTWV0cmljcyhmaWx0ZXJzPzoge1xuICAgIHN0YXJ0RGF0ZT86IERhdGU7XG4gICAgZW5kRGF0ZT86IERhdGU7XG4gICAgcGF5bWVudE1vZGVzPzogc3RyaW5nW107XG4gICAgbWVyY2hhbnRJZHM/OiBzdHJpbmdbXTtcbiAgICBwZ3M/OiBzdHJpbmdbXTtcbiAgICBiYW5rcz86IHN0cmluZ1tdO1xuICAgIGNhcmRUeXBlcz86IHN0cmluZ1tdO1xuICB9KTogUHJvbWlzZTx7XG4gICAgdG90YWxDb3VudDogbnVtYmVyO1xuICAgIHN1Y2Nlc3NDb3VudDogbnVtYmVyO1xuICAgIGZhaWxlZENvdW50OiBudW1iZXI7XG4gICAgdXNlckRyb3BwZWRDb3VudDogbnVtYmVyO1xuICAgIHN1Y2Nlc3NHbXY6IG51bWJlcjtcbiAgICBkYWlseVRyZW5kczogQXJyYXk8e1xuICAgICAgZGF0ZTogc3RyaW5nO1xuICAgICAgdm9sdW1lOiBudW1iZXI7XG4gICAgICBzdWNjZXNzQ291bnQ6IG51bWJlcjtcbiAgICAgIGZhaWxlZENvdW50OiBudW1iZXI7XG4gICAgICB1c2VyRHJvcHBlZENvdW50OiBudW1iZXI7XG4gICAgfT47XG4gIH0+IHtcbiAgICBhd2FpdCB0aGlzLmluaXQoKTtcbiAgICBpZiAoIXRoaXMuZGIpIHRocm93IG5ldyBFcnJvcignRGF0YWJhc2Ugbm90IGluaXRpYWxpemVkJyk7XG5cbiAgICBsZXQgdG90YWxDb3VudCA9IDA7XG4gICAgbGV0IHN1Y2Nlc3NDb3VudCA9IDA7XG4gICAgbGV0IGZhaWxlZENvdW50ID0gMDtcbiAgICBsZXQgdXNlckRyb3BwZWRDb3VudCA9IDA7XG4gICAgbGV0IHN1Y2Nlc3NHbXYgPSAwO1xuICAgIGNvbnN0IGRhaWx5TWFwID0gbmV3IE1hcDxzdHJpbmcsIHtcbiAgICAgIGRhdGU6IHN0cmluZztcbiAgICAgIHZvbHVtZTogbnVtYmVyO1xuICAgICAgc3VjY2Vzc0NvdW50OiBudW1iZXI7XG4gICAgICBmYWlsZWRDb3VudDogbnVtYmVyO1xuICAgICAgdXNlckRyb3BwZWRDb3VudDogbnVtYmVyO1xuICAgIH0+KCk7XG5cbiAgICBhd2FpdCB0aGlzLnN0cmVhbVRyYW5zYWN0aW9ucyhcbiAgICAgIGFzeW5jIChjaHVuaykgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IHR4IG9mIGNodW5rKSB7XG4gICAgICAgICAgdG90YWxDb3VudCsrO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmICh0eC5pc1N1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHN1Y2Nlc3NDb3VudCsrO1xuICAgICAgICAgICAgc3VjY2Vzc0dtdiArPSB0eC50eGFtb3VudCB8fCAwO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHguaXNGYWlsZWQpIHtcbiAgICAgICAgICAgIGZhaWxlZENvdW50Kys7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eC5pc1VzZXJEcm9wcGVkKSB7XG4gICAgICAgICAgICB1c2VyRHJvcHBlZENvdW50Kys7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IGRhdGUgPSB0eC50cmFuc2FjdGlvbkRhdGU7XG4gICAgICAgICAgaWYgKCFkYWlseU1hcC5oYXMoZGF0ZSkpIHtcbiAgICAgICAgICAgIGRhaWx5TWFwLnNldChkYXRlLCB7XG4gICAgICAgICAgICAgIGRhdGUsXG4gICAgICAgICAgICAgIHZvbHVtZTogMCxcbiAgICAgICAgICAgICAgc3VjY2Vzc0NvdW50OiAwLFxuICAgICAgICAgICAgICBmYWlsZWRDb3VudDogMCxcbiAgICAgICAgICAgICAgdXNlckRyb3BwZWRDb3VudDogMCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCB0cmVuZCA9IGRhaWx5TWFwLmdldChkYXRlKSE7XG4gICAgICAgICAgdHJlbmQudm9sdW1lKys7XG4gICAgICAgICAgaWYgKHR4LmlzU3VjY2VzcykgdHJlbmQuc3VjY2Vzc0NvdW50Kys7XG4gICAgICAgICAgaWYgKHR4LmlzRmFpbGVkKSB0cmVuZC5mYWlsZWRDb3VudCsrO1xuICAgICAgICAgIGlmICh0eC5pc1VzZXJEcm9wcGVkKSB0cmVuZC51c2VyRHJvcHBlZENvdW50Kys7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICA1MDAwMCxcbiAgICAgIGZpbHRlcnNcbiAgICApO1xuXG4gICAgY29uc3QgZGFpbHlUcmVuZHMgPSBBcnJheS5mcm9tKGRhaWx5TWFwLnZhbHVlcygpKVxuICAgICAgLnNvcnQoKGEsIGIpID0+IGEuZGF0ZS5sb2NhbGVDb21wYXJlKGIuZGF0ZSkpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRvdGFsQ291bnQsXG4gICAgICBzdWNjZXNzQ291bnQsXG4gICAgICBmYWlsZWRDb3VudCxcbiAgICAgIHVzZXJEcm9wcGVkQ291bnQsXG4gICAgICBzdWNjZXNzR212LFxuICAgICAgZGFpbHlUcmVuZHMsXG4gICAgfTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZGJNYW5hZ2VyID0gbmV3IEluZGV4ZWREQlRyYW5zYWN0aW9uTWFuYWdlcigpO1xuXG4iXSwibmFtZXMiOlsiREJfTkFNRSIsIlNUT1JFX05BTUUiLCJEQl9WRVJTSU9OIiwiSW5kZXhlZERCVHJhbnNhY3Rpb25NYW5hZ2VyIiwiaW5pdCIsImRiIiwiaW5pdFByb21pc2UiLCJ3aW5kb3ciLCJpbmRleGVkREIiLCJlcnJvciIsIkVycm9yIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJyZXF1ZXN0Iiwib3BlbiIsIm1lc3NhZ2UiLCJvbmVycm9yIiwiZXZlbnQiLCJ0YXJnZXQiLCJlcnJvck1lc3NhZ2UiLCJlcnJvck5hbWUiLCJuYW1lIiwidXNlck1lc3NhZ2UiLCJjb25zb2xlIiwib25ibG9ja2VkIiwid2FybiIsIm9uc3VjY2VzcyIsInJlc3VsdCIsIm9uY2xvc2UiLCJvbnZlcnNpb25jaGFuZ2UiLCJjbG9zZSIsIm9udXBncmFkZW5lZWRlZCIsImRhdGFiYXNlIiwib2JqZWN0U3RvcmVOYW1lcyIsImNvbnRhaW5zIiwiZGVsZXRlT2JqZWN0U3RvcmUiLCJvYmplY3RTdG9yZSIsImNyZWF0ZU9iamVjdFN0b3JlIiwia2V5UGF0aCIsImF1dG9JbmNyZW1lbnQiLCJjcmVhdGVJbmRleCIsInVuaXF1ZSIsInVwZ3JhZGVFcnJvciIsImNsZWFyIiwidHJhbnNhY3Rpb24iLCJzdG9yZSIsImdldENvdW50IiwiY291bnQiLCJhZGRUcmFuc2FjdGlvbnMiLCJ0cmFuc2FjdGlvbnMiLCJjaHVua1NpemUiLCJpIiwibGVuZ3RoIiwiY2h1bmsiLCJzbGljZSIsIm9uY29tcGxldGUiLCJmb3JFYWNoIiwidHgiLCJhZGQiLCJzZXRUaW1lb3V0Iiwic3RyZWFtVHJhbnNhY3Rpb25zIiwib25DaHVuayIsImZpbHRlcnMiLCJvcGVuQ3Vyc29yIiwicHJvY2Vzc2VkIiwiY3Vyc29yIiwidmFsdWUiLCJpbmNsdWRlIiwic3RhcnREYXRlIiwidHh0aW1lIiwiZW5kRGF0ZSIsInBheW1lbnRNb2RlcyIsImluY2x1ZGVzIiwicGF5bWVudG1vZGUiLCJtZXJjaGFudElkcyIsIm1lcmNoYW50SWQiLCJTdHJpbmciLCJtZXJjaGFudGlkIiwidHJpbSIsInBncyIsInBnIiwiYmFua3MiLCJmbG93IiwiYmFua25hbWUiLCJjYXJkVHlwZXMiLCJjYXJkdHlwZSIsInB1c2giLCJjb250aW51ZSIsImNodW5rVG9Qcm9jZXNzIiwiZ2V0QWxsVHJhbnNhY3Rpb25zIiwicmVzdWx0cyIsInNhbXBsZVRyYW5zYWN0aW9ucyIsIm1heFJvd3MiLCJyZW1haW5pbmciLCJnZXRGaWx0ZXJlZFRpbWVCb3VuZHMiLCJtaW5EYXRlIiwibWF4RGF0ZSIsInR4VGltZSIsIkRhdGUiLCJtaW4iLCJ1bmRlZmluZWQiLCJtYXgiLCJhZ2dyZWdhdGVNZXRyaWNzIiwidG90YWxDb3VudCIsInN1Y2Nlc3NDb3VudCIsImZhaWxlZENvdW50IiwidXNlckRyb3BwZWRDb3VudCIsInN1Y2Nlc3NHbXYiLCJkYWlseU1hcCIsIk1hcCIsImlzU3VjY2VzcyIsInR4YW1vdW50IiwiaXNGYWlsZWQiLCJpc1VzZXJEcm9wcGVkIiwiZGF0ZSIsInRyYW5zYWN0aW9uRGF0ZSIsImhhcyIsInNldCIsInZvbHVtZSIsInRyZW5kIiwiZ2V0IiwiZGFpbHlUcmVuZHMiLCJBcnJheSIsImZyb20iLCJ2YWx1ZXMiLCJzb3J0IiwiYSIsImIiLCJsb2NhbGVDb21wYXJlIiwiZGJNYW5hZ2VyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/indexeddb-manager.ts\n"));

/***/ })

});