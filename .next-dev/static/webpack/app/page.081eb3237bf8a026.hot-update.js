"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/indexeddb-manager.ts":
/*!**********************************!*\
  !*** ./lib/indexeddb-manager.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dbManager: function() { return /* binding */ dbManager; }\n/* harmony export */ });\n// IndexedDB Manager for large transaction datasets\n// Handles streaming writes and cursor-based reads to avoid loading all data into memory\nconst DB_NAME = \"sr-analytics-transactions\";\nconst STORE_NAME = \"transactions\";\nconst DB_VERSION = 3; // Increment when schema changes (v3: removed keyPath to fix storage issues)\nclass IndexedDBTransactionManager {\n    async init() {\n        if (this.db) return;\n        if (this.initPromise) return this.initPromise;\n        // Check if IndexedDB is available\n        if ( false || !window.indexedDB) {\n            const error = new Error(\"IndexedDB is not available in this browser. Please use a modern browser that supports IndexedDB.\");\n            this.initPromise = null;\n            throw error;\n        }\n        this.initPromise = new Promise((resolve, reject)=>{\n            let request;\n            try {\n                request = indexedDB.open(DB_NAME, DB_VERSION);\n            } catch (error) {\n                this.initPromise = null;\n                reject(new Error(\"Failed to open IndexedDB: \".concat((error === null || error === void 0 ? void 0 : error.message) || \"Unknown error\")));\n                return;\n            }\n            request.onerror = (event)=>{\n                var _event_target;\n                this.initPromise = null;\n                const error = (_event_target = event.target) === null || _event_target === void 0 ? void 0 : _event_target.error;\n                const errorMessage = (error === null || error === void 0 ? void 0 : error.message) || \"Unknown error\";\n                const errorName = (error === null || error === void 0 ? void 0 : error.name) || \"UnknownError\";\n                // Provide more specific error messages\n                let userMessage = \"Failed to open IndexedDB\";\n                if (errorName === \"QuotaExceededError\") {\n                    userMessage = \"IndexedDB quota exceeded. Please clear some browser storage or use a smaller file.\";\n                } else if (errorName === \"VersionError\") {\n                    userMessage = \"IndexedDB version conflict. Please refresh the page or clear browser storage.\";\n                } else if (errorName === \"InvalidStateError\") {\n                    userMessage = \"IndexedDB is in an invalid state. Please refresh the page.\";\n                } else if (errorName === \"AbortError\") {\n                    userMessage = \"IndexedDB operation was aborted. Please try again.\";\n                } else {\n                    userMessage = \"Failed to open IndexedDB: \".concat(errorMessage);\n                }\n                console.error(\"IndexedDB open error:\", errorName, errorMessage, error);\n                reject(new Error(userMessage));\n            };\n            request.onblocked = ()=>{\n                console.warn(\"IndexedDB upgrade blocked. Please close other tabs using this database.\");\n            // Don't reject here - the upgrade might complete later\n            };\n            request.onsuccess = ()=>{\n                this.db = request.result;\n                // Handle database close events\n                this.db.onerror = (event)=>{\n                    console.error(\"IndexedDB error:\", event);\n                };\n                this.db.onclose = ()=>{\n                    console.warn(\"IndexedDB connection closed\");\n                    this.db = null;\n                    this.initPromise = null;\n                };\n                this.db.onversionchange = ()=>{\n                    var _this_db;\n                    console.warn(\"IndexedDB version change detected. Please refresh the page.\");\n                    (_this_db = this.db) === null || _this_db === void 0 ? void 0 : _this_db.close();\n                    this.db = null;\n                    this.initPromise = null;\n                };\n                resolve();\n            };\n            request.onupgradeneeded = (event)=>{\n                const database = event.target.result;\n                try {\n                    // Delete old object store if it exists\n                    if (database.objectStoreNames.contains(STORE_NAME)) {\n                        database.deleteObjectStore(STORE_NAME);\n                    }\n                    // Create object store with indexes for efficient querying\n                    // Use autoIncrement without keyPath - IndexedDB will generate numeric keys automatically\n                    const objectStore = database.createObjectStore(STORE_NAME, {\n                        autoIncrement: true\n                    });\n                    // Create indexes for filtering\n                    objectStore.createIndex(\"txtime\", \"txtime\", {\n                        unique: false\n                    });\n                    objectStore.createIndex(\"paymentmode\", \"paymentmode\", {\n                        unique: false\n                    });\n                    objectStore.createIndex(\"merchantid\", \"merchantid\", {\n                        unique: false\n                    });\n                    objectStore.createIndex(\"pg\", \"pg\", {\n                        unique: false\n                    });\n                    objectStore.createIndex(\"bankname\", \"bankname\", {\n                        unique: false\n                    });\n                    objectStore.createIndex(\"cardtype\", \"cardtype\", {\n                        unique: false\n                    });\n                    objectStore.createIndex(\"transactionDate\", \"transactionDate\", {\n                        unique: false\n                    });\n                } catch (upgradeError) {\n                    console.error(\"IndexedDB upgrade error:\", upgradeError);\n                    reject(new Error(\"Failed to upgrade IndexedDB: \".concat((upgradeError === null || upgradeError === void 0 ? void 0 : upgradeError.message) || \"Unknown error\")));\n                }\n            };\n        });\n        return this.initPromise;\n    }\n    async clear() {\n        await this.init();\n        if (!this.db) throw new Error(\"Database not initialized\");\n        return new Promise((resolve, reject)=>{\n            const transaction = this.db.transaction([\n                STORE_NAME\n            ], \"readwrite\");\n            const store = transaction.objectStore(STORE_NAME);\n            const request = store.clear();\n            request.onerror = ()=>reject(request.error);\n            request.onsuccess = ()=>resolve();\n        });\n    }\n    async getCount() {\n        await this.init();\n        if (!this.db) throw new Error(\"Database not initialized\");\n        return new Promise((resolve, reject)=>{\n            const transaction = this.db.transaction([\n                STORE_NAME\n            ], \"readonly\");\n            const store = transaction.objectStore(STORE_NAME);\n            const request = store.count();\n            request.onerror = ()=>reject(request.error);\n            request.onsuccess = ()=>resolve(request.result);\n        });\n    }\n    async addTransactions(transactions) {\n        await this.init();\n        if (!this.db) throw new Error(\"Database not initialized\");\n        // Process in chunks to avoid blocking\n        const chunkSize = 10000;\n        for(let i = 0; i < transactions.length; i += chunkSize){\n            const chunk = transactions.slice(i, i + chunkSize);\n            await new Promise((resolve, reject)=>{\n                const transaction = this.db.transaction([\n                    STORE_NAME\n                ], \"readwrite\");\n                const store = transaction.objectStore(STORE_NAME);\n                transaction.onerror = ()=>reject(transaction.error);\n                transaction.oncomplete = ()=>resolve();\n                chunk.forEach((tx)=>{\n                    store.add(tx);\n                });\n            });\n            // Yield to browser after each chunk\n            if (i + chunkSize < transactions.length) {\n                await new Promise((resolve)=>setTimeout(resolve, 0));\n            }\n        }\n    }\n    async streamTransactions(onChunk) {\n        let chunkSize = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 50000, filters = arguments.length > 2 ? arguments[2] : void 0;\n        await this.init();\n        if (!this.db) throw new Error(\"Database not initialized\");\n        return new Promise((resolve, reject)=>{\n            const transaction = this.db.transaction([\n                STORE_NAME\n            ], \"readonly\");\n            const store = transaction.objectStore(STORE_NAME);\n            const request = store.openCursor();\n            let chunk = [];\n            let pendingChunks = [];\n            let hasError = false;\n            // Process all pending chunks asynchronously (outside transaction)\n            const processAllPendingChunks = async ()=>{\n                for (const chunkToProcess of pendingChunks){\n                    if (hasError) return;\n                    try {\n                        await onChunk(chunkToProcess);\n                        // Yield to browser periodically\n                        await new Promise((resolve)=>setTimeout(resolve, 0));\n                    } catch (error) {\n                        hasError = true;\n                        reject(error);\n                        return;\n                    }\n                }\n            };\n            request.onerror = ()=>{\n                hasError = true;\n                reject(request.error);\n            };\n            request.onsuccess = (event)=>{\n                if (hasError) return;\n                const cursor = event.target.result;\n                if (!cursor) {\n                    // Queue last chunk if any\n                    if (chunk.length > 0) {\n                        pendingChunks.push([\n                            ...chunk\n                        ]);\n                        chunk = [];\n                    }\n                    // Process all pending chunks after transaction completes\n                    transaction.oncomplete = async ()=>{\n                        try {\n                            await processAllPendingChunks();\n                            if (!hasError) resolve();\n                        } catch (error) {\n                            if (!hasError) {\n                                hasError = true;\n                                reject(error);\n                            }\n                        }\n                    };\n                    return;\n                }\n                const tx = cursor.value;\n                // Apply filters synchronously (must be fast, no async)\n                let include = true;\n                if (filters) {\n                    if (filters.startDate && tx.txtime < filters.startDate) include = false;\n                    if (filters.endDate && tx.txtime > filters.endDate) include = false;\n                    if (filters.paymentModes && filters.paymentModes.length > 0) {\n                        if (!filters.paymentModes.includes(tx.paymentmode)) include = false;\n                    }\n                    if (filters.merchantIds && filters.merchantIds.length > 0) {\n                        const merchantId = String(tx.merchantid || \"\").trim();\n                        if (!filters.merchantIds.includes(merchantId)) include = false;\n                    }\n                    if (filters.pgs && filters.pgs.length > 0) {\n                        if (!filters.pgs.includes(tx.pg)) include = false;\n                    }\n                    if (filters.banks && filters.banks.length > 0) {\n                        const flow = tx.bankname || \"\";\n                        if (!filters.banks.includes(flow) && !filters.banks.includes(tx.bankname || \"\")) include = false;\n                    }\n                    if (filters.cardTypes && filters.cardTypes.length > 0) {\n                        if (!filters.cardTypes.includes(tx.cardtype)) include = false;\n                    }\n                }\n                if (include) {\n                    chunk.push(tx);\n                }\n                // When chunk is large enough, queue it for async processing (after transaction)\n                if (chunk.length >= chunkSize) {\n                    const chunkToProcess = [\n                        ...chunk\n                    ];\n                    chunk = [];\n                    pendingChunks.push(chunkToProcess);\n                }\n                // Continue cursor synchronously (transaction still active)\n                // Must call continue() before any async operations\n                cursor.continue();\n            };\n            // Handle transaction errors\n            transaction.onerror = ()=>{\n                hasError = true;\n                reject(transaction.error);\n            };\n        });\n    }\n    async getAllTransactions(filters) {\n        const results = [];\n        await this.streamTransactions(async (chunk)=>{\n            results.push(...chunk);\n        }, 50000, filters);\n        return results;\n    }\n    async sampleTransactions(maxRows, filters) {\n        const results = [];\n        await this.streamTransactions(async (chunk)=>{\n            if (results.length < maxRows) {\n                const remaining = maxRows - results.length;\n                results.push(...chunk.slice(0, remaining));\n            }\n        }, 50000, filters);\n        return results;\n    }\n    async getFilteredTimeBounds(filters) {\n        await this.init();\n        if (!this.db) throw new Error(\"Database not initialized\");\n        let minDate = null;\n        let maxDate = null;\n        await this.streamTransactions(async (chunk)=>{\n            for (const tx of chunk){\n                const txTime = tx.txtime instanceof Date ? tx.txtime : new Date(tx.txtime);\n                if (!minDate || txTime < minDate) minDate = txTime;\n                if (!maxDate || txTime > maxDate) maxDate = txTime;\n            }\n        }, 50000, filters);\n        return {\n            min: minDate || undefined,\n            max: maxDate || undefined\n        };\n    }\n    async aggregateMetrics(filters) {\n        await this.init();\n        if (!this.db) throw new Error(\"Database not initialized\");\n        let totalCount = 0;\n        let successCount = 0;\n        let failedCount = 0;\n        let userDroppedCount = 0;\n        let successGmv = 0;\n        const dailyMap = new Map();\n        await this.streamTransactions(async (chunk)=>{\n            for (const tx of chunk){\n                totalCount++;\n                if (tx.isSuccess) {\n                    successCount++;\n                    successGmv += tx.txamount || 0;\n                } else if (tx.isFailed) {\n                    failedCount++;\n                } else if (tx.isUserDropped) {\n                    userDroppedCount++;\n                }\n                const date = tx.transactionDate;\n                if (!dailyMap.has(date)) {\n                    dailyMap.set(date, {\n                        date,\n                        volume: 0,\n                        successCount: 0,\n                        failedCount: 0,\n                        userDroppedCount: 0\n                    });\n                }\n                const trend = dailyMap.get(date);\n                trend.volume++;\n                if (tx.isSuccess) trend.successCount++;\n                if (tx.isFailed) trend.failedCount++;\n                if (tx.isUserDropped) trend.userDroppedCount++;\n            }\n        }, 50000, filters);\n        const dailyTrends = Array.from(dailyMap.values()).sort((a, b)=>a.date.localeCompare(b.date));\n        return {\n            totalCount,\n            successCount,\n            failedCount,\n            userDroppedCount,\n            successGmv,\n            dailyTrends\n        };\n    }\n    constructor(){\n        this.db = null;\n        this.initPromise = null;\n    }\n}\nconst dbManager = new IndexedDBTransactionManager();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9pbmRleGVkZGItbWFuYWdlci50cyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsbURBQW1EO0FBQ25ELHdGQUF3RjtBQUl4RixNQUFNQSxVQUFVO0FBQ2hCLE1BQU1DLGFBQWE7QUFDbkIsTUFBTUMsYUFBYSxHQUFHLDRFQUE0RTtBQXVCbEcsTUFBTUM7SUFJSixNQUFNQyxPQUFzQjtRQUMxQixJQUFJLElBQUksQ0FBQ0MsRUFBRSxFQUFFO1FBQ2IsSUFBSSxJQUFJLENBQUNDLFdBQVcsRUFBRSxPQUFPLElBQUksQ0FBQ0EsV0FBVztRQUU3QyxrQ0FBa0M7UUFDbEMsSUFBSSxNQUFrQixJQUFlLENBQUNDLE9BQU9DLFNBQVMsRUFBRTtZQUN0RCxNQUFNQyxRQUFRLElBQUlDLE1BQU07WUFDeEIsSUFBSSxDQUFDSixXQUFXLEdBQUc7WUFDbkIsTUFBTUc7UUFDUjtRQUVBLElBQUksQ0FBQ0gsV0FBVyxHQUFHLElBQUlLLFFBQVEsQ0FBQ0MsU0FBU0M7WUFDdkMsSUFBSUM7WUFFSixJQUFJO2dCQUNGQSxVQUFVTixVQUFVTyxJQUFJLENBQUNmLFNBQVNFO1lBQ3BDLEVBQUUsT0FBT08sT0FBWTtnQkFDbkIsSUFBSSxDQUFDSCxXQUFXLEdBQUc7Z0JBQ25CTyxPQUFPLElBQUlILE1BQU0sNkJBQStELE9BQWxDRCxDQUFBQSxrQkFBQUEsNEJBQUFBLE1BQU9PLE9BQU8sS0FBSTtnQkFDaEU7WUFDRjtZQUVBRixRQUFRRyxPQUFPLEdBQUcsQ0FBQ0M7b0JBRUZBO2dCQURmLElBQUksQ0FBQ1osV0FBVyxHQUFHO2dCQUNuQixNQUFNRyxTQUFTUyxnQkFBQUEsTUFBTUMsTUFBTSxjQUFaRCxvQ0FBRCxjQUE4QlQsS0FBSztnQkFDakQsTUFBTVcsZUFBZVgsQ0FBQUEsa0JBQUFBLDRCQUFBQSxNQUFPTyxPQUFPLEtBQUk7Z0JBQ3ZDLE1BQU1LLFlBQVlaLENBQUFBLGtCQUFBQSw0QkFBQUEsTUFBT2EsSUFBSSxLQUFJO2dCQUVqQyx1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LElBQUlqRCxHQUFHeUQsUUFBUSxFQUFFTyxNQUFNZCxXQUFXO2dCQUNsQyxJQUFJbEQsR0FBRzBELGFBQWEsRUFBRU0sTUFBTWIsZ0JBQWdCO1lBQzlDO1FBQ0YsR0FDQSxPQUNBOUM7UUFHRixNQUFNNkQsY0FBY0MsTUFBTUMsSUFBSSxDQUFDZixTQUFTZ0IsTUFBTSxJQUMzQ0MsSUFBSSxDQUFDLENBQUNDLEdBQUdDLElBQU1ELEVBQUVaLElBQUksQ0FBQ2MsYUFBYSxDQUFDRCxFQUFFYixJQUFJO1FBRTdDLE9BQU87WUFDTFg7WUFDQUM7WUFDQUM7WUFDQUM7WUFDQUM7WUFDQWM7UUFDRjtJQUNGOzthQWpjUXRILEtBQXlCO2FBQ3pCQyxjQUFvQzs7QUFpYzlDO0FBRU8sTUFBTTZILFlBQVksSUFBSWhJLDhCQUE4QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvaW5kZXhlZGRiLW1hbmFnZXIudHM/MTdiZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbmRleGVkREIgTWFuYWdlciBmb3IgbGFyZ2UgdHJhbnNhY3Rpb24gZGF0YXNldHNcbi8vIEhhbmRsZXMgc3RyZWFtaW5nIHdyaXRlcyBhbmQgY3Vyc29yLWJhc2VkIHJlYWRzIHRvIGF2b2lkIGxvYWRpbmcgYWxsIGRhdGEgaW50byBtZW1vcnlcblxuaW1wb3J0IHsgVHJhbnNhY3Rpb24gfSBmcm9tICdAL3R5cGVzJztcblxuY29uc3QgREJfTkFNRSA9ICdzci1hbmFseXRpY3MtdHJhbnNhY3Rpb25zJztcbmNvbnN0IFNUT1JFX05BTUUgPSAndHJhbnNhY3Rpb25zJztcbmNvbnN0IERCX1ZFUlNJT04gPSAzOyAvLyBJbmNyZW1lbnQgd2hlbiBzY2hlbWEgY2hhbmdlcyAodjM6IHJlbW92ZWQga2V5UGF0aCB0byBmaXggc3RvcmFnZSBpc3N1ZXMpXG5cbmludGVyZmFjZSBEQk1hbmFnZXIge1xuICBpbml0KCk6IFByb21pc2U8dm9pZD47XG4gIGNsZWFyKCk6IFByb21pc2U8dm9pZD47XG4gIGdldENvdW50KCk6IFByb21pc2U8bnVtYmVyPjtcbiAgYWRkVHJhbnNhY3Rpb25zKHRyYW5zYWN0aW9uczogVHJhbnNhY3Rpb25bXSk6IFByb21pc2U8dm9pZD47XG4gIHN0cmVhbVRyYW5zYWN0aW9ucyhcbiAgICBvbkNodW5rOiAoY2h1bms6IFRyYW5zYWN0aW9uW10pID0+IFByb21pc2U8dm9pZD4sXG4gICAgY2h1bmtTaXplPzogbnVtYmVyLFxuICAgIGZpbHRlcnM/OiB7XG4gICAgICBzdGFydERhdGU/OiBEYXRlO1xuICAgICAgZW5kRGF0ZT86IERhdGU7XG4gICAgICBwYXltZW50TW9kZXM/OiBzdHJpbmdbXTtcbiAgICAgIG1lcmNoYW50SWRzPzogc3RyaW5nW107XG4gICAgICBwZ3M/OiBzdHJpbmdbXTtcbiAgICAgIGJhbmtzPzogc3RyaW5nW107XG4gICAgICBjYXJkVHlwZXM/OiBzdHJpbmdbXTtcbiAgICB9XG4gICk6IFByb21pc2U8dm9pZD47XG4gIGdldEFsbFRyYW5zYWN0aW9ucyhmaWx0ZXJzPzogYW55KTogUHJvbWlzZTxUcmFuc2FjdGlvbltdPjtcbn1cblxuY2xhc3MgSW5kZXhlZERCVHJhbnNhY3Rpb25NYW5hZ2VyIGltcGxlbWVudHMgREJNYW5hZ2VyIHtcbiAgcHJpdmF0ZSBkYjogSURCRGF0YWJhc2UgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBpbml0UHJvbWlzZTogUHJvbWlzZTx2b2lkPiB8IG51bGwgPSBudWxsO1xuXG4gIGFzeW5jIGluaXQoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHRoaXMuZGIpIHJldHVybjtcbiAgICBpZiAodGhpcy5pbml0UHJvbWlzZSkgcmV0dXJuIHRoaXMuaW5pdFByb21pc2U7XG5cbiAgICAvLyBDaGVjayBpZiBJbmRleGVkREIgaXMgYXZhaWxhYmxlXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICF3aW5kb3cuaW5kZXhlZERCKSB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignSW5kZXhlZERCIGlzIG5vdCBhdmFpbGFibGUgaW4gdGhpcyBicm93c2VyLiBQbGVhc2UgdXNlIGEgbW9kZXJuIGJyb3dzZXIgdGhhdCBzdXBwb3J0cyBJbmRleGVkREIuJyk7XG4gICAgICB0aGlzLmluaXRQcm9taXNlID0gbnVsbDtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIHRoaXMuaW5pdFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBsZXQgcmVxdWVzdDogSURCT3BlbkRCUmVxdWVzdDtcbiAgICAgIFxuICAgICAgdHJ5IHtcbiAgICAgICAgcmVxdWVzdCA9IGluZGV4ZWREQi5vcGVuKERCX05BTUUsIERCX1ZFUlNJT04pO1xuICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICB0aGlzLmluaXRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgRmFpbGVkIHRvIG9wZW4gSW5kZXhlZERCOiAke2Vycm9yPy5tZXNzYWdlIHx8ICdVbmtub3duIGVycm9yJ31gKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVxdWVzdC5vbmVycm9yID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIHRoaXMuaW5pdFByb21pc2UgPSBudWxsO1xuICAgICAgICBjb25zdCBlcnJvciA9IChldmVudC50YXJnZXQgYXMgSURCUmVxdWVzdCk/LmVycm9yO1xuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvcj8ubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcic7XG4gICAgICAgIGNvbnN0IGVycm9yTmFtZSA9IGVycm9yPy5uYW1lIHx8ICdVbmtub3duRXJyb3InO1xuICAgICAgICBcbiAgICAgICAgLy8gUHJvdmlkZSBtb3JlIHNwZWNpZmljIGVycm9yIG1lc3NhZ2VzXG4gICAgICAgIGxldCB1c2VyTWVzc2FnZSA9ICdGYWlsZWQgdG8gb3BlbiBJbmRleGVkREInO1xuICAgICAgICBpZiAoZXJyb3JOYW1lID09PSAnUXVvdGFFeGNlZWRlZEVycm9yJykge1xuICAgICAgICAgIHVzZXJNZXNzYWdlID0gJ0luZGV4ZWREQiBxdW90YSBleGNlZWRlZC4gUGxlYXNlIGNsZWFyIHNvbWUgYnJvd3NlciBzdG9yYWdlIG9yIHVzZSBhIHNtYWxsZXIgZmlsZS4nO1xuICAgICAgICB9IGVsc2UgaWYgKGVycm9yTmFtZSA9PT0gJ1ZlcnNpb25FcnJvcicpIHtcbiAgICAgICAgICB1c2VyTWVzc2FnZSA9ICdJbmRleGVkREIgdmVyc2lvbiBjb25mbGljdC4gUGxlYXNlIHJlZnJlc2ggdGhlIHBhZ2Ugb3IgY2xlYXIgYnJvd3NlciBzdG9yYWdlLic7XG4gICAgICAgIH0gZWxzZSBpZiAoZXJyb3JOYW1lID09PSAnSW52YWxpZFN0YXRlRXJyb3InKSB7XG4gICAgICAgICAgdXNlck1lc3NhZ2UgPSAnSW5kZXhlZERCIGlzIGluIGFuIGludmFsaWQgc3RhdGUuIFBsZWFzZSByZWZyZXNoIHRoZSBwYWdlLic7XG4gICAgICAgIH0gZWxzZSBpZiAoZXJyb3JOYW1lID09PSAnQWJvcnRFcnJvcicpIHtcbiAgICAgICAgICB1c2VyTWVzc2FnZSA9ICdJbmRleGVkREIgb3BlcmF0aW9uIHdhcyBhYm9ydGVkLiBQbGVhc2UgdHJ5IGFnYWluLic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXNlck1lc3NhZ2UgPSBgRmFpbGVkIHRvIG9wZW4gSW5kZXhlZERCOiAke2Vycm9yTWVzc2FnZX1gO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmVycm9yKCdJbmRleGVkREIgb3BlbiBlcnJvcjonLCBlcnJvck5hbWUsIGVycm9yTWVzc2FnZSwgZXJyb3IpO1xuICAgICAgICByZWplY3QobmV3IEVycm9yKHVzZXJNZXNzYWdlKSk7XG4gICAgICB9O1xuXG4gICAgICByZXF1ZXN0Lm9uYmxvY2tlZCA9ICgpID0+IHtcbiAgICAgICAgY29uc29sZS53YXJuKCdJbmRleGVkREIgdXBncmFkZSBibG9ja2VkLiBQbGVhc2UgY2xvc2Ugb3RoZXIgdGFicyB1c2luZyB0aGlzIGRhdGFiYXNlLicpO1xuICAgICAgICAvLyBEb24ndCByZWplY3QgaGVyZSAtIHRoZSB1cGdyYWRlIG1pZ2h0IGNvbXBsZXRlIGxhdGVyXG4gICAgICB9O1xuXG4gICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5kYiA9IHJlcXVlc3QucmVzdWx0O1xuICAgICAgICBcbiAgICAgICAgLy8gSGFuZGxlIGRhdGFiYXNlIGNsb3NlIGV2ZW50c1xuICAgICAgICB0aGlzLmRiLm9uZXJyb3IgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdJbmRleGVkREIgZXJyb3I6JywgZXZlbnQpO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgdGhpcy5kYi5vbmNsb3NlID0gKCkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUud2FybignSW5kZXhlZERCIGNvbm5lY3Rpb24gY2xvc2VkJyk7XG4gICAgICAgICAgdGhpcy5kYiA9IG51bGw7XG4gICAgICAgICAgdGhpcy5pbml0UHJvbWlzZSA9IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICB0aGlzLmRiLm9udmVyc2lvbmNoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ0luZGV4ZWREQiB2ZXJzaW9uIGNoYW5nZSBkZXRlY3RlZC4gUGxlYXNlIHJlZnJlc2ggdGhlIHBhZ2UuJyk7XG4gICAgICAgICAgdGhpcy5kYj8uY2xvc2UoKTtcbiAgICAgICAgICB0aGlzLmRiID0gbnVsbDtcbiAgICAgICAgICB0aGlzLmluaXRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH07XG5cbiAgICAgIHJlcXVlc3Qub251cGdyYWRlbmVlZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IGRhdGFiYXNlID0gKGV2ZW50LnRhcmdldCBhcyBJREJPcGVuREJSZXF1ZXN0KS5yZXN1bHQ7XG4gICAgICAgIFxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIERlbGV0ZSBvbGQgb2JqZWN0IHN0b3JlIGlmIGl0IGV4aXN0c1xuICAgICAgICAgIGlmIChkYXRhYmFzZS5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKFNUT1JFX05BTUUpKSB7XG4gICAgICAgICAgICBkYXRhYmFzZS5kZWxldGVPYmplY3RTdG9yZShTVE9SRV9OQU1FKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDcmVhdGUgb2JqZWN0IHN0b3JlIHdpdGggaW5kZXhlcyBmb3IgZWZmaWNpZW50IHF1ZXJ5aW5nXG4gICAgICAgICAgLy8gVXNlIGF1dG9JbmNyZW1lbnQgd2l0aG91dCBrZXlQYXRoIC0gSW5kZXhlZERCIHdpbGwgZ2VuZXJhdGUgbnVtZXJpYyBrZXlzIGF1dG9tYXRpY2FsbHlcbiAgICAgICAgICBjb25zdCBvYmplY3RTdG9yZSA9IGRhdGFiYXNlLmNyZWF0ZU9iamVjdFN0b3JlKFNUT1JFX05BTUUsIHtcbiAgICAgICAgICAgIGF1dG9JbmNyZW1lbnQ6IHRydWUsXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBDcmVhdGUgaW5kZXhlcyBmb3IgZmlsdGVyaW5nXG4gICAgICAgICAgb2JqZWN0U3RvcmUuY3JlYXRlSW5kZXgoJ3R4dGltZScsICd0eHRpbWUnLCB7IHVuaXF1ZTogZmFsc2UgfSk7XG4gICAgICAgICAgb2JqZWN0U3RvcmUuY3JlYXRlSW5kZXgoJ3BheW1lbnRtb2RlJywgJ3BheW1lbnRtb2RlJywgeyB1bmlxdWU6IGZhbHNlIH0pO1xuICAgICAgICAgIG9iamVjdFN0b3JlLmNyZWF0ZUluZGV4KCdtZXJjaGFudGlkJywgJ21lcmNoYW50aWQnLCB7IHVuaXF1ZTogZmFsc2UgfSk7XG4gICAgICAgICAgb2JqZWN0U3RvcmUuY3JlYXRlSW5kZXgoJ3BnJywgJ3BnJywgeyB1bmlxdWU6IGZhbHNlIH0pO1xuICAgICAgICAgIG9iamVjdFN0b3JlLmNyZWF0ZUluZGV4KCdiYW5rbmFtZScsICdiYW5rbmFtZScsIHsgdW5pcXVlOiBmYWxzZSB9KTtcbiAgICAgICAgICBvYmplY3RTdG9yZS5jcmVhdGVJbmRleCgnY2FyZHR5cGUnLCAnY2FyZHR5cGUnLCB7IHVuaXF1ZTogZmFsc2UgfSk7XG4gICAgICAgICAgb2JqZWN0U3RvcmUuY3JlYXRlSW5kZXgoJ3RyYW5zYWN0aW9uRGF0ZScsICd0cmFuc2FjdGlvbkRhdGUnLCB7IHVuaXF1ZTogZmFsc2UgfSk7XG4gICAgICAgIH0gY2F0Y2ggKHVwZ3JhZGVFcnJvcjogYW55KSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignSW5kZXhlZERCIHVwZ3JhZGUgZXJyb3I6JywgdXBncmFkZUVycm9yKTtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBGYWlsZWQgdG8gdXBncmFkZSBJbmRleGVkREI6ICR7dXBncmFkZUVycm9yPy5tZXNzYWdlIHx8ICdVbmtub3duIGVycm9yJ31gKSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5pbml0UHJvbWlzZTtcbiAgfVxuXG4gIGFzeW5jIGNsZWFyKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHRoaXMuaW5pdCgpO1xuICAgIGlmICghdGhpcy5kYikgdGhyb3cgbmV3IEVycm9yKCdEYXRhYmFzZSBub3QgaW5pdGlhbGl6ZWQnKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRoaXMuZGIhLnRyYW5zYWN0aW9uKFtTVE9SRV9OQU1FXSwgJ3JlYWR3cml0ZScpO1xuICAgICAgY29uc3Qgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShTVE9SRV9OQU1FKTtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5jbGVhcigpO1xuXG4gICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiByZWplY3QocmVxdWVzdC5lcnJvcik7XG4gICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHJlc29sdmUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGdldENvdW50KCk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgYXdhaXQgdGhpcy5pbml0KCk7XG4gICAgaWYgKCF0aGlzLmRiKSB0aHJvdyBuZXcgRXJyb3IoJ0RhdGFiYXNlIG5vdCBpbml0aWFsaXplZCcpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy5kYiEudHJhbnNhY3Rpb24oW1NUT1JFX05BTUVdLCAncmVhZG9ubHknKTtcbiAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoU1RPUkVfTkFNRSk7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gc3RvcmUuY291bnQoKTtcblxuICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4gcmVqZWN0KHJlcXVlc3QuZXJyb3IpO1xuICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiByZXNvbHZlKHJlcXVlc3QucmVzdWx0KTtcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGFkZFRyYW5zYWN0aW9ucyh0cmFuc2FjdGlvbnM6IFRyYW5zYWN0aW9uW10pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCB0aGlzLmluaXQoKTtcbiAgICBpZiAoIXRoaXMuZGIpIHRocm93IG5ldyBFcnJvcignRGF0YWJhc2Ugbm90IGluaXRpYWxpemVkJyk7XG5cbiAgICAvLyBQcm9jZXNzIGluIGNodW5rcyB0byBhdm9pZCBibG9ja2luZ1xuICAgIGNvbnN0IGNodW5rU2l6ZSA9IDEwMDAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhbnNhY3Rpb25zLmxlbmd0aDsgaSArPSBjaHVua1NpemUpIHtcbiAgICAgIGNvbnN0IGNodW5rID0gdHJhbnNhY3Rpb25zLnNsaWNlKGksIGkgKyBjaHVua1NpemUpO1xuICAgICAgXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy5kYiEudHJhbnNhY3Rpb24oW1NUT1JFX05BTUVdLCAncmVhZHdyaXRlJyk7XG4gICAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoU1RPUkVfTkFNRSk7XG5cbiAgICAgICAgdHJhbnNhY3Rpb24ub25lcnJvciA9ICgpID0+IHJlamVjdCh0cmFuc2FjdGlvbi5lcnJvcik7XG4gICAgICAgIHRyYW5zYWN0aW9uLm9uY29tcGxldGUgPSAoKSA9PiByZXNvbHZlKCk7XG5cbiAgICAgICAgY2h1bmsuZm9yRWFjaCgodHgpID0+IHtcbiAgICAgICAgICBzdG9yZS5hZGQodHgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBZaWVsZCB0byBicm93c2VyIGFmdGVyIGVhY2ggY2h1bmtcbiAgICAgIGlmIChpICsgY2h1bmtTaXplIDwgdHJhbnNhY3Rpb25zLmxlbmd0aCkge1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHN0cmVhbVRyYW5zYWN0aW9ucyhcbiAgICBvbkNodW5rOiAoY2h1bms6IFRyYW5zYWN0aW9uW10pID0+IFByb21pc2U8dm9pZD4sXG4gICAgY2h1bmtTaXplOiBudW1iZXIgPSA1MDAwMCxcbiAgICBmaWx0ZXJzPzoge1xuICAgICAgc3RhcnREYXRlPzogRGF0ZTtcbiAgICAgIGVuZERhdGU/OiBEYXRlO1xuICAgICAgcGF5bWVudE1vZGVzPzogc3RyaW5nW107XG4gICAgICBtZXJjaGFudElkcz86IHN0cmluZ1tdO1xuICAgICAgcGdzPzogc3RyaW5nW107XG4gICAgICBiYW5rcz86IHN0cmluZ1tdO1xuICAgICAgY2FyZFR5cGVzPzogc3RyaW5nW107XG4gICAgfVxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCB0aGlzLmluaXQoKTtcbiAgICBpZiAoIXRoaXMuZGIpIHRocm93IG5ldyBFcnJvcignRGF0YWJhc2Ugbm90IGluaXRpYWxpemVkJyk7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSB0aGlzLmRiIS50cmFuc2FjdGlvbihbU1RPUkVfTkFNRV0sICdyZWFkb25seScpO1xuICAgICAgY29uc3Qgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShTVE9SRV9OQU1FKTtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5vcGVuQ3Vyc29yKCk7XG4gICAgICBcbiAgICAgIGxldCBjaHVuazogVHJhbnNhY3Rpb25bXSA9IFtdO1xuICAgICAgbGV0IHBlbmRpbmdDaHVua3M6IFRyYW5zYWN0aW9uW11bXSA9IFtdO1xuICAgICAgbGV0IGhhc0Vycm9yID0gZmFsc2U7XG5cbiAgICAgIC8vIFByb2Nlc3MgYWxsIHBlbmRpbmcgY2h1bmtzIGFzeW5jaHJvbm91c2x5IChvdXRzaWRlIHRyYW5zYWN0aW9uKVxuICAgICAgY29uc3QgcHJvY2Vzc0FsbFBlbmRpbmdDaHVua3MgPSBhc3luYyAoKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgY2h1bmtUb1Byb2Nlc3Mgb2YgcGVuZGluZ0NodW5rcykge1xuICAgICAgICAgIGlmIChoYXNFcnJvcikgcmV0dXJuO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBvbkNodW5rKGNodW5rVG9Qcm9jZXNzKTtcbiAgICAgICAgICAgIC8vIFlpZWxkIHRvIGJyb3dzZXIgcGVyaW9kaWNhbGx5XG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBoYXNFcnJvciA9IHRydWU7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICBoYXNFcnJvciA9IHRydWU7XG4gICAgICAgIHJlamVjdChyZXF1ZXN0LmVycm9yKTtcbiAgICAgIH07XG5cbiAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChoYXNFcnJvcikgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0IGN1cnNvciA9IChldmVudC50YXJnZXQgYXMgSURCUmVxdWVzdDxJREJDdXJzb3JXaXRoVmFsdWU+KS5yZXN1bHQ7XG4gICAgICAgIFxuICAgICAgICBpZiAoIWN1cnNvcikge1xuICAgICAgICAgIC8vIFF1ZXVlIGxhc3QgY2h1bmsgaWYgYW55XG4gICAgICAgICAgaWYgKGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHBlbmRpbmdDaHVua3MucHVzaChbLi4uY2h1bmtdKTtcbiAgICAgICAgICAgIGNodW5rID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIFByb2Nlc3MgYWxsIHBlbmRpbmcgY2h1bmtzIGFmdGVyIHRyYW5zYWN0aW9uIGNvbXBsZXRlc1xuICAgICAgICAgIHRyYW5zYWN0aW9uLm9uY29tcGxldGUgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBhd2FpdCBwcm9jZXNzQWxsUGVuZGluZ0NodW5rcygpO1xuICAgICAgICAgICAgICBpZiAoIWhhc0Vycm9yKSByZXNvbHZlKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBpZiAoIWhhc0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgaGFzRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIFxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHR4ID0gY3Vyc29yLnZhbHVlIGFzIFRyYW5zYWN0aW9uO1xuXG4gICAgICAgIC8vIEFwcGx5IGZpbHRlcnMgc3luY2hyb25vdXNseSAobXVzdCBiZSBmYXN0LCBubyBhc3luYylcbiAgICAgICAgbGV0IGluY2x1ZGUgPSB0cnVlO1xuICAgICAgICBcbiAgICAgICAgaWYgKGZpbHRlcnMpIHtcbiAgICAgICAgICBpZiAoZmlsdGVycy5zdGFydERhdGUgJiYgdHgudHh0aW1lIDwgZmlsdGVycy5zdGFydERhdGUpIGluY2x1ZGUgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoZmlsdGVycy5lbmREYXRlICYmIHR4LnR4dGltZSA+IGZpbHRlcnMuZW5kRGF0ZSkgaW5jbHVkZSA9IGZhbHNlO1xuICAgICAgICAgIGlmIChmaWx0ZXJzLnBheW1lbnRNb2RlcyAmJiBmaWx0ZXJzLnBheW1lbnRNb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAoIWZpbHRlcnMucGF5bWVudE1vZGVzLmluY2x1ZGVzKHR4LnBheW1lbnRtb2RlKSkgaW5jbHVkZSA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZmlsdGVycy5tZXJjaGFudElkcyAmJiBmaWx0ZXJzLm1lcmNoYW50SWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IG1lcmNoYW50SWQgPSBTdHJpbmcodHgubWVyY2hhbnRpZCB8fCAnJykudHJpbSgpO1xuICAgICAgICAgICAgaWYgKCFmaWx0ZXJzLm1lcmNoYW50SWRzLmluY2x1ZGVzKG1lcmNoYW50SWQpKSBpbmNsdWRlID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmaWx0ZXJzLnBncyAmJiBmaWx0ZXJzLnBncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAoIWZpbHRlcnMucGdzLmluY2x1ZGVzKHR4LnBnKSkgaW5jbHVkZSA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZmlsdGVycy5iYW5rcyAmJiBmaWx0ZXJzLmJhbmtzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGZsb3cgPSB0eC5iYW5rbmFtZSB8fCAnJztcbiAgICAgICAgICAgIGlmICghZmlsdGVycy5iYW5rcy5pbmNsdWRlcyhmbG93KSAmJiAhZmlsdGVycy5iYW5rcy5pbmNsdWRlcyh0eC5iYW5rbmFtZSB8fCAnJykpIGluY2x1ZGUgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGZpbHRlcnMuY2FyZFR5cGVzICYmIGZpbHRlcnMuY2FyZFR5cGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmICghZmlsdGVycy5jYXJkVHlwZXMuaW5jbHVkZXModHguY2FyZHR5cGUpKSBpbmNsdWRlID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluY2x1ZGUpIHtcbiAgICAgICAgICBjaHVuay5wdXNoKHR4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdoZW4gY2h1bmsgaXMgbGFyZ2UgZW5vdWdoLCBxdWV1ZSBpdCBmb3IgYXN5bmMgcHJvY2Vzc2luZyAoYWZ0ZXIgdHJhbnNhY3Rpb24pXG4gICAgICAgIGlmIChjaHVuay5sZW5ndGggPj0gY2h1bmtTaXplKSB7XG4gICAgICAgICAgY29uc3QgY2h1bmtUb1Byb2Nlc3MgPSBbLi4uY2h1bmtdO1xuICAgICAgICAgIGNodW5rID0gW107XG4gICAgICAgICAgcGVuZGluZ0NodW5rcy5wdXNoKGNodW5rVG9Qcm9jZXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbnRpbnVlIGN1cnNvciBzeW5jaHJvbm91c2x5ICh0cmFuc2FjdGlvbiBzdGlsbCBhY3RpdmUpXG4gICAgICAgIC8vIE11c3QgY2FsbCBjb250aW51ZSgpIGJlZm9yZSBhbnkgYXN5bmMgb3BlcmF0aW9uc1xuICAgICAgICBjdXJzb3IuY29udGludWUoKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIEhhbmRsZSB0cmFuc2FjdGlvbiBlcnJvcnNcbiAgICAgIHRyYW5zYWN0aW9uLm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgIGhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgcmVqZWN0KHRyYW5zYWN0aW9uLmVycm9yKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBnZXRBbGxUcmFuc2FjdGlvbnMoZmlsdGVycz86IGFueSk6IFByb21pc2U8VHJhbnNhY3Rpb25bXT4ge1xuICAgIGNvbnN0IHJlc3VsdHM6IFRyYW5zYWN0aW9uW10gPSBbXTtcbiAgICBcbiAgICBhd2FpdCB0aGlzLnN0cmVhbVRyYW5zYWN0aW9ucyhcbiAgICAgIGFzeW5jIChjaHVuaykgPT4ge1xuICAgICAgICByZXN1bHRzLnB1c2goLi4uY2h1bmspO1xuICAgICAgfSxcbiAgICAgIDUwMDAwLFxuICAgICAgZmlsdGVyc1xuICAgICk7XG5cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIGFzeW5jIHNhbXBsZVRyYW5zYWN0aW9ucyhtYXhSb3dzOiBudW1iZXIsIGZpbHRlcnM/OiB7XG4gICAgc3RhcnREYXRlPzogRGF0ZTtcbiAgICBlbmREYXRlPzogRGF0ZTtcbiAgICBwYXltZW50TW9kZXM/OiBzdHJpbmdbXTtcbiAgICBtZXJjaGFudElkcz86IHN0cmluZ1tdO1xuICAgIHBncz86IHN0cmluZ1tdO1xuICAgIGJhbmtzPzogc3RyaW5nW107XG4gICAgY2FyZFR5cGVzPzogc3RyaW5nW107XG4gIH0pOiBQcm9taXNlPFRyYW5zYWN0aW9uW10+IHtcbiAgICBjb25zdCByZXN1bHRzOiBUcmFuc2FjdGlvbltdID0gW107XG4gICAgXG4gICAgYXdhaXQgdGhpcy5zdHJlYW1UcmFuc2FjdGlvbnMoXG4gICAgICBhc3luYyAoY2h1bmspID0+IHtcbiAgICAgICAgaWYgKHJlc3VsdHMubGVuZ3RoIDwgbWF4Um93cykge1xuICAgICAgICAgIGNvbnN0IHJlbWFpbmluZyA9IG1heFJvd3MgLSByZXN1bHRzLmxlbmd0aDtcbiAgICAgICAgICByZXN1bHRzLnB1c2goLi4uY2h1bmsuc2xpY2UoMCwgcmVtYWluaW5nKSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICA1MDAwMCxcbiAgICAgIGZpbHRlcnNcbiAgICApO1xuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICBhc3luYyBnZXRGaWx0ZXJlZFRpbWVCb3VuZHMoZmlsdGVycz86IHtcbiAgICBzdGFydERhdGU/OiBEYXRlO1xuICAgIGVuZERhdGU/OiBEYXRlO1xuICAgIHBheW1lbnRNb2Rlcz86IHN0cmluZ1tdO1xuICAgIG1lcmNoYW50SWRzPzogc3RyaW5nW107XG4gICAgcGdzPzogc3RyaW5nW107XG4gICAgYmFua3M/OiBzdHJpbmdbXTtcbiAgICBjYXJkVHlwZXM/OiBzdHJpbmdbXTtcbiAgfSk6IFByb21pc2U8eyBtaW4/OiBEYXRlOyBtYXg/OiBEYXRlIH0+IHtcbiAgICBhd2FpdCB0aGlzLmluaXQoKTtcbiAgICBpZiAoIXRoaXMuZGIpIHRocm93IG5ldyBFcnJvcignRGF0YWJhc2Ugbm90IGluaXRpYWxpemVkJyk7XG5cbiAgICBsZXQgbWluRGF0ZTogRGF0ZSB8IG51bGwgPSBudWxsO1xuICAgIGxldCBtYXhEYXRlOiBEYXRlIHwgbnVsbCA9IG51bGw7XG5cbiAgICBhd2FpdCB0aGlzLnN0cmVhbVRyYW5zYWN0aW9ucyhcbiAgICAgIGFzeW5jIChjaHVuaykgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IHR4IG9mIGNodW5rKSB7XG4gICAgICAgICAgY29uc3QgdHhUaW1lID0gdHgudHh0aW1lIGluc3RhbmNlb2YgRGF0ZSA/IHR4LnR4dGltZSA6IG5ldyBEYXRlKHR4LnR4dGltZSk7XG4gICAgICAgICAgaWYgKCFtaW5EYXRlIHx8IHR4VGltZSA8IG1pbkRhdGUpIG1pbkRhdGUgPSB0eFRpbWU7XG4gICAgICAgICAgaWYgKCFtYXhEYXRlIHx8IHR4VGltZSA+IG1heERhdGUpIG1heERhdGUgPSB0eFRpbWU7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICA1MDAwMCxcbiAgICAgIGZpbHRlcnNcbiAgICApO1xuXG4gICAgcmV0dXJuIHsgXG4gICAgICBtaW46IG1pbkRhdGUgfHwgdW5kZWZpbmVkLCBcbiAgICAgIG1heDogbWF4RGF0ZSB8fCB1bmRlZmluZWQgXG4gICAgfTtcbiAgfVxuXG4gIGFzeW5jIGFnZ3JlZ2F0ZU1ldHJpY3MoZmlsdGVycz86IHtcbiAgICBzdGFydERhdGU/OiBEYXRlO1xuICAgIGVuZERhdGU/OiBEYXRlO1xuICAgIHBheW1lbnRNb2Rlcz86IHN0cmluZ1tdO1xuICAgIG1lcmNoYW50SWRzPzogc3RyaW5nW107XG4gICAgcGdzPzogc3RyaW5nW107XG4gICAgYmFua3M/OiBzdHJpbmdbXTtcbiAgICBjYXJkVHlwZXM/OiBzdHJpbmdbXTtcbiAgfSk6IFByb21pc2U8e1xuICAgIHRvdGFsQ291bnQ6IG51bWJlcjtcbiAgICBzdWNjZXNzQ291bnQ6IG51bWJlcjtcbiAgICBmYWlsZWRDb3VudDogbnVtYmVyO1xuICAgIHVzZXJEcm9wcGVkQ291bnQ6IG51bWJlcjtcbiAgICBzdWNjZXNzR212OiBudW1iZXI7XG4gICAgZGFpbHlUcmVuZHM6IEFycmF5PHtcbiAgICAgIGRhdGU6IHN0cmluZztcbiAgICAgIHZvbHVtZTogbnVtYmVyO1xuICAgICAgc3VjY2Vzc0NvdW50OiBudW1iZXI7XG4gICAgICBmYWlsZWRDb3VudDogbnVtYmVyO1xuICAgICAgdXNlckRyb3BwZWRDb3VudDogbnVtYmVyO1xuICAgIH0+O1xuICB9PiB7XG4gICAgYXdhaXQgdGhpcy5pbml0KCk7XG4gICAgaWYgKCF0aGlzLmRiKSB0aHJvdyBuZXcgRXJyb3IoJ0RhdGFiYXNlIG5vdCBpbml0aWFsaXplZCcpO1xuXG4gICAgbGV0IHRvdGFsQ291bnQgPSAwO1xuICAgIGxldCBzdWNjZXNzQ291bnQgPSAwO1xuICAgIGxldCBmYWlsZWRDb3VudCA9IDA7XG4gICAgbGV0IHVzZXJEcm9wcGVkQ291bnQgPSAwO1xuICAgIGxldCBzdWNjZXNzR212ID0gMDtcbiAgICBjb25zdCBkYWlseU1hcCA9IG5ldyBNYXA8c3RyaW5nLCB7XG4gICAgICBkYXRlOiBzdHJpbmc7XG4gICAgICB2b2x1bWU6IG51bWJlcjtcbiAgICAgIHN1Y2Nlc3NDb3VudDogbnVtYmVyO1xuICAgICAgZmFpbGVkQ291bnQ6IG51bWJlcjtcbiAgICAgIHVzZXJEcm9wcGVkQ291bnQ6IG51bWJlcjtcbiAgICB9PigpO1xuXG4gICAgYXdhaXQgdGhpcy5zdHJlYW1UcmFuc2FjdGlvbnMoXG4gICAgICBhc3luYyAoY2h1bmspID0+IHtcbiAgICAgICAgZm9yIChjb25zdCB0eCBvZiBjaHVuaykge1xuICAgICAgICAgIHRvdGFsQ291bnQrKztcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAodHguaXNTdWNjZXNzKSB7XG4gICAgICAgICAgICBzdWNjZXNzQ291bnQrKztcbiAgICAgICAgICAgIHN1Y2Nlc3NHbXYgKz0gdHgudHhhbW91bnQgfHwgMDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR4LmlzRmFpbGVkKSB7XG4gICAgICAgICAgICBmYWlsZWRDb3VudCsrO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHguaXNVc2VyRHJvcHBlZCkge1xuICAgICAgICAgICAgdXNlckRyb3BwZWRDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCBkYXRlID0gdHgudHJhbnNhY3Rpb25EYXRlO1xuICAgICAgICAgIGlmICghZGFpbHlNYXAuaGFzKGRhdGUpKSB7XG4gICAgICAgICAgICBkYWlseU1hcC5zZXQoZGF0ZSwge1xuICAgICAgICAgICAgICBkYXRlLFxuICAgICAgICAgICAgICB2b2x1bWU6IDAsXG4gICAgICAgICAgICAgIHN1Y2Nlc3NDb3VudDogMCxcbiAgICAgICAgICAgICAgZmFpbGVkQ291bnQ6IDAsXG4gICAgICAgICAgICAgIHVzZXJEcm9wcGVkQ291bnQ6IDAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgdHJlbmQgPSBkYWlseU1hcC5nZXQoZGF0ZSkhO1xuICAgICAgICAgIHRyZW5kLnZvbHVtZSsrO1xuICAgICAgICAgIGlmICh0eC5pc1N1Y2Nlc3MpIHRyZW5kLnN1Y2Nlc3NDb3VudCsrO1xuICAgICAgICAgIGlmICh0eC5pc0ZhaWxlZCkgdHJlbmQuZmFpbGVkQ291bnQrKztcbiAgICAgICAgICBpZiAodHguaXNVc2VyRHJvcHBlZCkgdHJlbmQudXNlckRyb3BwZWRDb3VudCsrO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgNTAwMDAsXG4gICAgICBmaWx0ZXJzXG4gICAgKTtcblxuICAgIGNvbnN0IGRhaWx5VHJlbmRzID0gQXJyYXkuZnJvbShkYWlseU1hcC52YWx1ZXMoKSlcbiAgICAgIC5zb3J0KChhLCBiKSA9PiBhLmRhdGUubG9jYWxlQ29tcGFyZShiLmRhdGUpKTtcblxuICAgIHJldHVybiB7XG4gICAgICB0b3RhbENvdW50LFxuICAgICAgc3VjY2Vzc0NvdW50LFxuICAgICAgZmFpbGVkQ291bnQsXG4gICAgICB1c2VyRHJvcHBlZENvdW50LFxuICAgICAgc3VjY2Vzc0dtdixcbiAgICAgIGRhaWx5VHJlbmRzLFxuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGRiTWFuYWdlciA9IG5ldyBJbmRleGVkREJUcmFuc2FjdGlvbk1hbmFnZXIoKTtcblxuIl0sIm5hbWVzIjpbIkRCX05BTUUiLCJTVE9SRV9OQU1FIiwiREJfVkVSU0lPTiIsIkluZGV4ZWREQlRyYW5zYWN0aW9uTWFuYWdlciIsImluaXQiLCJkYiIsImluaXRQcm9taXNlIiwid2luZG93IiwiaW5kZXhlZERCIiwiZXJyb3IiLCJFcnJvciIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwicmVxdWVzdCIsIm9wZW4iLCJtZXNzYWdlIiwib25lcnJvciIsImV2ZW50IiwidGFyZ2V0IiwiZXJyb3JNZXNzYWdlIiwiZXJyb3JOYW1lIiwibmFtZSIsInVzZXJNZXNzYWdlIiwiY29uc29sZSIsIm9uYmxvY2tlZCIsIndhcm4iLCJvbnN1Y2Nlc3MiLCJyZXN1bHQiLCJvbmNsb3NlIiwib252ZXJzaW9uY2hhbmdlIiwiY2xvc2UiLCJvbnVwZ3JhZGVuZWVkZWQiLCJkYXRhYmFzZSIsIm9iamVjdFN0b3JlTmFtZXMiLCJjb250YWlucyIsImRlbGV0ZU9iamVjdFN0b3JlIiwib2JqZWN0U3RvcmUiLCJjcmVhdGVPYmplY3RTdG9yZSIsImF1dG9JbmNyZW1lbnQiLCJjcmVhdGVJbmRleCIsInVuaXF1ZSIsInVwZ3JhZGVFcnJvciIsImNsZWFyIiwidHJhbnNhY3Rpb24iLCJzdG9yZSIsImdldENvdW50IiwiY291bnQiLCJhZGRUcmFuc2FjdGlvbnMiLCJ0cmFuc2FjdGlvbnMiLCJjaHVua1NpemUiLCJpIiwibGVuZ3RoIiwiY2h1bmsiLCJzbGljZSIsIm9uY29tcGxldGUiLCJmb3JFYWNoIiwidHgiLCJhZGQiLCJzZXRUaW1lb3V0Iiwic3RyZWFtVHJhbnNhY3Rpb25zIiwib25DaHVuayIsImZpbHRlcnMiLCJvcGVuQ3Vyc29yIiwicGVuZGluZ0NodW5rcyIsImhhc0Vycm9yIiwicHJvY2Vzc0FsbFBlbmRpbmdDaHVua3MiLCJjaHVua1RvUHJvY2VzcyIsImN1cnNvciIsInB1c2giLCJ2YWx1ZSIsImluY2x1ZGUiLCJzdGFydERhdGUiLCJ0eHRpbWUiLCJlbmREYXRlIiwicGF5bWVudE1vZGVzIiwiaW5jbHVkZXMiLCJwYXltZW50bW9kZSIsIm1lcmNoYW50SWRzIiwibWVyY2hhbnRJZCIsIlN0cmluZyIsIm1lcmNoYW50aWQiLCJ0cmltIiwicGdzIiwicGciLCJiYW5rcyIsImZsb3ciLCJiYW5rbmFtZSIsImNhcmRUeXBlcyIsImNhcmR0eXBlIiwiY29udGludWUiLCJnZXRBbGxUcmFuc2FjdGlvbnMiLCJyZXN1bHRzIiwic2FtcGxlVHJhbnNhY3Rpb25zIiwibWF4Um93cyIsInJlbWFpbmluZyIsImdldEZpbHRlcmVkVGltZUJvdW5kcyIsIm1pbkRhdGUiLCJtYXhEYXRlIiwidHhUaW1lIiwiRGF0ZSIsIm1pbiIsInVuZGVmaW5lZCIsIm1heCIsImFnZ3JlZ2F0ZU1ldHJpY3MiLCJ0b3RhbENvdW50Iiwic3VjY2Vzc0NvdW50IiwiZmFpbGVkQ291bnQiLCJ1c2VyRHJvcHBlZENvdW50Iiwic3VjY2Vzc0dtdiIsImRhaWx5TWFwIiwiTWFwIiwiaXNTdWNjZXNzIiwidHhhbW91bnQiLCJpc0ZhaWxlZCIsImlzVXNlckRyb3BwZWQiLCJkYXRlIiwidHJhbnNhY3Rpb25EYXRlIiwiaGFzIiwic2V0Iiwidm9sdW1lIiwidHJlbmQiLCJnZXQiLCJkYWlseVRyZW5kcyIsIkFycmF5IiwiZnJvbSIsInZhbHVlcyIsInNvcnQiLCJhIiwiYiIsImxvY2FsZUNvbXBhcmUiLCJkYk1hbmFnZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/indexeddb-manager.ts\n"));

/***/ })

});